<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js coal">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Notes</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Notes on learning Rust programming language.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "coal";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('coal')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Readme</a></li><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="create_book.html"><strong aria-hidden="true">3.</strong> Creating a Book</a></li><li class="chapter-item expanded "><a href="cargo.html"><strong aria-hidden="true">4.</strong> Cargo</a></li><li class="chapter-item expanded "><a href="crates.html"><strong aria-hidden="true">5.</strong> Crates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="crates/anymap.html"><strong aria-hidden="true">5.1.</strong> anymap</a></li><li class="chapter-item expanded "><a href="crates/notify.html"><strong aria-hidden="true">5.2.</strong> notify</a></li></ol></li><li class="chapter-item expanded "><a href="github_init.html"><strong aria-hidden="true">6.</strong> Storing on GitHub</a></li><li class="chapter-item expanded "><a href="sample_code.html"><strong aria-hidden="true">7.</strong> Sample Code</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="samples/hello_world.html"><strong aria-hidden="true">7.1.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="samples/rust_cookbook.html"><strong aria-hidden="true">7.2.</strong> Rust Cookbook</a></li><li class="chapter-item expanded "><a href="samples/rosetta.html"><strong aria-hidden="true">7.3.</strong> Rosetta Code</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="samples/rosetta/100_doors.html"><strong aria-hidden="true">7.3.1.</strong> 100 Doors</a></li><li class="chapter-item expanded "><a href="samples/rosetta/100_prisoners.html"><strong aria-hidden="true">7.3.2.</strong> 100 Prisoners</a></li><li class="chapter-item expanded "><a href="samples/rosetta/15_puzzle_game.html"><strong aria-hidden="true">7.3.3.</strong> 15 Puzzle Game</a></li><li class="chapter-item expanded "><a href="samples/rosetta/15_puzzle_solver.html"><strong aria-hidden="true">7.3.4.</strong> 15 puzzle solver</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="linux.html"><strong aria-hidden="true">8.</strong> Linux Environment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="non_rust.html"><strong aria-hidden="true">8.1.</strong> Non-Rust Utilities</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="terminator.html"><strong aria-hidden="true">8.1.1.</strong> Terminator</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="language_features.html"><strong aria-hidden="true">9.</strong> Language Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language_features/destructor.html"><strong aria-hidden="true">9.1.</strong> Destructuror</a></li><li class="chapter-item expanded "><a href="language_features/memory.html"><strong aria-hidden="true">9.2.</strong> Memory</a></li><li class="chapter-item expanded "><a href="language_features/trait_objects.html"><strong aria-hidden="true">9.3.</strong> Trait Objectss</a></li><li class="chapter-item expanded "><a href="language_features/traits.html"><strong aria-hidden="true">9.4.</strong> Traits</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language_features/traits/memory.html"><strong aria-hidden="true">9.4.1.</strong> Iterator</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="language_limitations.html"><strong aria-hidden="true">10.</strong> Language Limitations</a></li><li class="chapter-item expanded "><a href="best_practices.html"><strong aria-hidden="true">11.</strong> Best Practices</a></li><li class="chapter-item expanded "><a href="miscellaneous.html"><strong aria-hidden="true">12.</strong> Miscellaneous</a></li><li class="chapter-item expanded "><a href="glossary.html"><strong aria-hidden="true">13.</strong> Glossary</a></li><li class="chapter-item expanded "><a href="troubleshooting.html"><strong aria-hidden="true">14.</strong> Troubleshooting</a></li><li class="chapter-item expanded "><a href="quiz.html"><strong aria-hidden="true">15.</strong> Quiz</a></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">16.</strong> References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rust Notes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#my-rust-notes" id="my-rust-notes">My Rust Notes</a></h1>
<p>As part of writing my notes, I am storing them using gitbook-like clone <em>mdbook</em>.
This repo serves the dual purpose of documenting my experience
and documenting how I went about documenting.</p>
<p>As a byproduct, this repo will have commands and instructions for
creating a new empty book.</p>
<h2><a class="header" href="#goals" id="goals">Goals</a></h2>
<ul>
<li>create a wrapper crate for mdbook to create new books.</li>
</ul>
<h2><a class="header" href="#build" id="build">Build</a></h2>
<ul>
<li>Build/View the book locally: <code>mdbook build --open</code></li>
<li>Rebuild/View loop: <code>mdbook watch --open</code></li>
</ul>
<h2><a class="header" href="#installbootstrap" id="installbootstrap">Install/Bootstrap</a></h2>
<ul>
<li>View the published book:  <a href="https://joemooney.github.io/rust-notes/">https://joemooney.github.io/rust-notes/</a></li>
<li>GitHub source code for book: <a href="https://github.com/joemooney/rust-notes/">https://github.com/joemooney/rust-notes/</a>
-- View the book locally: <a href="file:///home/jpm/rust/rust-notes/book/index.html">file:///home/jpm/rust/rust-notes/book/index.html</a></li>
</ul>
<p>Once you have opened the book the rest of the instructions for
setting up a new book, editing, publishing etc. are within the book itself.</p>
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p><sub><span style='color:gray'><em>Last Updated: 2020-08-16 22:14:24</em></span></sub></p>
<p>This book contains notes from learning Rust.
It will also contain notes on how I wrote this book.</p>
<p>In order to create this book and play around with Rust, I have used the following tools:</p>
<ul>
<li>rust
<ul>
<li>cargo
<ul>
<li>mdbook</li>
</ul>
</li>
</ul>
</li>
<li>GitHub
<ul>
<li>GitHub Pages</li>
</ul>
</li>
<li>hub</li>
<li>git</li>
<li>rsync</li>
<li>VS Code
<ul>
<li>Extensions (listing ones I like and use, not all needed for this books)
<ul>
<li>docs-markdown :star: ⬅️ Alt-M to see help</li>
<li>Git Graph</li>
<li>GitLens</li>
<li>Rust</li>
<li>TabNine</li>
<li>Vim</li>
</ul>
</li>
</ul>
</li>
<li>Firefox
<ul>
<li>Extensions
<ul>
<li>vimium ⬅️ <em>?</em> for help when in browser, navigate in browser like Vim</li>
</ul>
</li>
</ul>
</li>
<li>Linux
<ul>
<li>terminator</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#create-a-book" id="create-a-book">Create a Book</a></h1>
<p>Create a markdown book with mdbook crate.
This is the crate used to create the official 
Rust Programming Book.
It is also the crate I used to this book.
mdbook allows you to add preprocessors so that you can have your own custom markdown extensions (like I am doing).</p>
<ul>
<li>cargo install mdbook</li>
<li>mkdir mybook</li>
<li>cd mybook</li>
<li>mdbook init</li>
</ul>
<p>For my preprocessor I googled and found <a href="https://github.com/badboy/mdbook-toc/blob/master/Cargo.toml">mdbook-toc</a>
which I cloned and gutted to create my own preprocessor.
If I want a Table of Contents, I will use mdbook-toc.
For my preprocessor so far all I need is just a simple
global search an replace.
Preprocessors are powerful, they have access to the entire parsed token tree. This allows you much finer grain control over the substitutions.</p>
<p>To publish the book I use a simple shell script:</p>
<pre><code class="language-bash">
url=$(git config --get remote.origin.url | sed 's,git@github.com:,,;s,/,.github.io/,;s,^,https://,;s,.git$,/,')

    lang=shell
    mdbook build                                          &amp;&amp; \
    postprocess                                           &amp;&amp; \
    rsync -avx --delete --info=progress2 ./book/ ./docs/  &amp;&amp;\
    git status                                            &amp;&amp; \
    echo 'git commit -am'                                 &amp;&amp; \
    echo -n &quot;Comment: &quot; &amp;&amp; read comment                   &amp;&amp; \
    git add .                                             &amp;&amp; \
    git commit -am &quot;$comment&quot;                             &amp;&amp; \
    git push                                              &amp;&amp; \
    echo &quot;Published: $url

</code></pre>
<p>There are some more guards such as checking for no git untracked files and no other git uncommitted updates.</p>
<p>As I am editing the book, I have <code>mdbook watch --open</code> running which opens a browser and regenerates the book every time it changes.</p>
<h2><a class="header" href="#preprocessors" id="preprocessors">Preprocessors</a></h2>
<p>Upon <code>cargo install mdbook-mermaid</code> in <em>book.toml</em> add:</p>
<pre><code class="language-toml">[preprocessor.mermaid]
renderer = [&quot;html&quot;, &quot;epub&quot;]
</code></pre>
<p>Then we go:
stateDiagram
state &quot;Also Cool&quot; as s1
s1: foo/bar
[<em>] --&gt; Cool
Cool --&gt; s1
s1 --&gt; Coolest
Coolest --&gt; [</em>]</p>
<h1><a class="header" href="#cargo" id="cargo">Cargo</a></h1>
<ul>
<li>To upgrade all your your existing crates you have installed run <code>cargo install-update -a</code></li>
</ul>
<p>Say you have an existing directory, an empty git repo.
To turn this into a Rust project you run <code>cargo init . --bin</code>
If you then execute <code>cargo run</code> it will compile and run it, printing out <strong>Hello World!</strong>*</p>
<h1><a class="header" href="#crates" id="crates">Crates</a></h1>
<p>Crates are libraries or binaries that are typically stored in <a href="http://crates.io">crates.io</a></p>
<p>Here are some crates that are awesome:</p>
<ul>
<li><a href="https://crates.io/crates/anymap">anymap</a></li>
<li><a href="crates/anymap.html">anymap</a></li>
</ul>
<p>There are so many great crates and the running cargo install is a breeze (although it can take some time depending on the dependencies).</p>
<ul>
<li>cargo install <a href="https://github.com/badboy/mdbook-mermaid">mdbook-mermaid</a>
<ul>
<li>cool flowcharts and other graphs for your book</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#anymap-crate" id="anymap-crate">AnyMap Crate</a></h1>
<p><a href="https://zsiciarz.github.io/24daysofrust/book/vol1/day9.html">credits</a>
<a href="https://crates.io/crates/anymap">anymap</a></p>
<p>Map a key to a value where the key is a type and the value is an instance of that type.</p>
<ul>
<li>Store configuration data</li>
<li>Singleton</li>
</ul>
<p>Create lots of simple types, for example</p>
<pre><pre class="playpen"><code class="language-rust editable">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>extern crate anymap;

use std::net::Ipv4Addr;
use anymap::AnyMap;

#[derive(Debug)]
enum HostAddress {
    DomainName(String),
    Ip(Ipv4Addr),
}

#[derive(Debug)]
struct Port(u32);

#[derive(Debug)]
struct ConnectionLimit(u32);

let mut config = AnyMap::new();
config.insert(HostAddress::DomainName(&quot;siciarz.net&quot;.to_string()));
config.insert(Port(666));
config.insert(ConnectionLimit(32));
println!(&quot;{:?}&quot;, config.get::&lt;HostAddress&gt;());
println!(&quot;{:?}&quot;, config.get::&lt;Port&gt;());
assert!(config.get::&lt;String&gt;().is_none());
assert!(config.get::&lt;u32&gt;().is_none());
<span class="boring">}
</span></code></pre></pre>
<p>Here we have types e.g. <strong>Port</strong> instead of having a port being a member of some struct we can have an AnyMap and have Port as one of the keys.</p>
<h1><a class="header" href="#notify" id="notify">notify</a></h1>
<h2><a class="header" href="#a-hrefhttpsstackoverflowcomquestions55440289how-do-i-recursively-watch-file-changes-in-rusthow-do-i-recursively-watch-file-changes-in-rusta" id="a-hrefhttpsstackoverflowcomquestions55440289how-do-i-recursively-watch-file-changes-in-rusthow-do-i-recursively-watch-file-changes-in-rusta"><a href="https://stackoverflow.com/questions/55440289/how-do-i-recursively-watch-file-changes-in-rust">How do I recursively watch file changes in Rust?</a></a></h2>
<p>This example watches a directory for changes and upon a change an event is received</p>
<pre><pre class="playpen"><code class="language-rust">
use notify::{Watcher, RecursiveMode, watcher};
use std::sync::mpsc::channel;
use std::time::Duration;

fn main() {
    // Create a channel to receive the events.
    let (sender, receiver) = channel();

    // Create a watcher object, delivering debounced events.
    // The notification back-end is selected based on the platform.
    // The Duration is how long after the event that you will
    // receive the notification. If this is too short then you
    // may end up taking an action before the event is complete.
    // For example, if a file is written to you may try something
    // before it is finished writing.
    let mut watcher = watcher(sender, Duration::from_secs(2)).unwrap();

    // Add a path to be watched. All files and directories at that path and
    // below will be monitored for changes.
    watcher.watch(&quot;/path/to/watch&quot;, RecursiveMode::Recursive).unwrap();

    loop {
        match receiver.recv() {
           Ok(event) =&gt; println!(&quot;{:?}&quot;, event),
           Err(e) =&gt; println!(&quot;watch error: {:?}&quot;, e),
        }
    }
}
</code></pre></pre>
<h1><a class="header" href="#storing-on-github" id="storing-on-github">Storing on github</a></h1>
<p>Create a repo locally:</p>
<ul>
<li><code>mdbook rust-book</code> ⬅️ this will create the directory with a bare bones book</li>
<li><code>cd rust-book</code></li>
<li><code>git init</code></li>
</ul>
<p>Then I installed <em>hub</em> command to simplify working with github:</p>
<ul>
<li><code>sudo snap install [hub](https://hub.github.com/) --classic</code></li>
<li><code>hub create</code> &gt; [!TIP]
<blockquote>
<p>This will create the repo on GitHub, you will be prompted from user/password first time thru.</p>
</blockquote>
</li>
<li><code>git remote show origin</code></li>
<li><code>git push --set-upstream origin master</code></li>
</ul>
<p>After creating some content for the book and pushing the changes to GitHub,
I then ran <code>mdbook build</code> which generated a <em>book</em> directory.</p>
<ul>
<li><code>mdbook build --open</code></li>
<li>Once you are happy with the changes you can publish.</li>
<li><code>mv book docs</code></li>
<li><code>git add docs</code> ⬅️ this must be the name. It is what GitHub Pages requires.</li>
<li><code>git commit -m 'adding my book for the first time'</code></li>
<li>On GitHub, under <em>Settings</em> for the repo, under <em>GitHub Pages</em> section, I selected <em>Source master branch/docs</em></li>
<li><code>git push</code></li>
<li>The link to your site will be shown as <a href="https://joemooney.github.io/rust-notes/">https://&lt;your_id&gt;.github.io/&lt;your_repo&gt;/</a></li>
<li>After you make changes to the book you can sync the <em>book</em> and <em>docs</em> directories.</li>
<li><code>rsync -avx --delete --info=progress2 ./book/ ./docs/</code></li>
<li><code>git push</code></li>
</ul>
<h1><a class="header" href="#sample-code" id="sample-code">Sample Code</a></h1>
<p>Here we go through code samples from various sources on the web.</p>
<h1><a class="header" href="#hello-world" id="hello-world">Hello World</a></h1>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    print!(&quot;Hello World!&quot;);
}
</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let number = 5;
    print!(&quot;{}&quot;, number);
}
</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust editable">//TODO: how dow import in an mdbook block of code? use itertools::Itertools;
fn main() {
    let numbers = vec![1,2,3,4,5,6,7,8,9];
    // To use itertools
    // numbers.foreach(|i| print!(&quot;{}&quot;, i));
    for i in numbers {
        print!(&quot;{}&quot;, i);
    }
}
</code></pre></pre>
<h1><a class="header" href="#a-hrefhttpsrust-lang-nurserygithubiorust-cookbookrust-cookbooka" id="a-hrefhttpsrust-lang-nurserygithubiorust-cookbookrust-cookbooka"><a href="https://rust-lang-nursery.github.io/rust-cookbook/">Rust Cookbook</a></a></h1>
<p>The code is all taken from the <a href="https://rust-lang-nursery.github.io/rust-cookbook/">Rust Cookbook</a>, the links are back to the Rust Cookbook. The snippets here are just a condensed version without explanation. Read the Rust Cookbook to understand.</p>
<h2><a class="header" href="#a-hrefhttpsrust-lang-nurserygithubiorust-cookbookalgorithmsrandomnesshtmlgenerate-random-numbersrandom-numbersa" id="a-hrefhttpsrust-lang-nurserygithubiorust-cookbookalgorithmsrandomnesshtmlgenerate-random-numbersrandom-numbersa"><a href="https://rust-lang-nursery.github.io/rust-cookbook/algorithms/randomness.html#generate-random-numbers">Random Numbers</a></a></h2>
<pre><pre class="playpen"><code class="language-rust editable">extern crate rand;

use rand::Rng;

fn main() {
    let mut rng = rand::thread_rng();

    let n1: u8 = rng.gen();
    let n2: u16 = rng.gen();
    println!(&quot;Random u8: {}&quot;, n1);
    println!(&quot;Random u16: {}&quot;, n2);
    println!(&quot;Random u32: {}&quot;, rng.gen::&lt;u32&gt;());
    println!(&quot;Random i32: {}&quot;, rng.gen::&lt;i32&gt;());
    println!(&quot;Random float: {}&quot;, rng.gen::&lt;f64&gt;());
    println!(&quot;Integer: {}&quot;, rng.gen_range(0, 10));
    println!(&quot;Float: {}&quot;, rng.gen_range(0.0, 10.0));
}
</code></pre></pre>
<h2><a class="header" href="#a-hrefhttpsrust-lang-nurserygithubiorust-cookbookalgorithmssortinghtmlsortinga" id="a-hrefhttpsrust-lang-nurserygithubiorust-cookbookalgorithmssortinghtmlsortinga"><a href="https://rust-lang-nursery.github.io/rust-cookbook/algorithms/sorting.html">Sorting</a></a></h2>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let mut vec = vec![1, 5, 10, 2, 15];

    vec.sort();

    assert_eq!(vec, vec![1, 2, 5, 10, 15]);
}
</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust editable">#[derive(Debug, Eq, Ord, PartialEq, PartialOrd)]
struct Person {
    name: String,
    age: u32
}

impl Person {
    pub fn new(name: String, age: u32) -&gt; Self {
        Person {
            name,
            age
        }
    }
}

fn main() {
    let mut people = vec![
        Person::new(&quot;Zoe&quot;.to_string(), 25),
        Person::new(&quot;Al&quot;.to_string(), 60),
        Person::new(&quot;John&quot;.to_string(), 1),
    ];

    // Sort people by derived natural order (Name and age)
    people.sort();

    assert_eq!(
        people,
        vec![
            Person::new(&quot;Al&quot;.to_string(), 60),
            Person::new(&quot;John&quot;.to_string(), 1),
            Person::new(&quot;Zoe&quot;.to_string(), 25),
        ]);

    // Sort people by age
    people.sort_by(|a, b| b.age.cmp(&amp;a.age));

    assert_eq!(
        people,
        vec![
            Person::new(&quot;Al&quot;.to_string(), 60),
            Person::new(&quot;Zoe&quot;.to_string(), 25),
            Person::new(&quot;John&quot;.to_string(), 1),
        ]);

}
</code></pre></pre>
<h2><a class="header" href="#a-hrefhttpsrust-lang-nurserygithubiorust-cookbookcliargumentshtmlcommand-line-argument-parsinga" id="a-hrefhttpsrust-lang-nurserygithubiorust-cookbookcliargumentshtmlcommand-line-argument-parsinga"><a href="https://rust-lang-nursery.github.io/rust-cookbook/cli/arguments.html">Command Line Argument Parsing</a></a></h2>
<pre><pre class="playpen"><code class="language-rust editable">use clap::{Arg, App};

fn main() {
    let matches = App::new(&quot;My Test Program&quot;)
        .version(&quot;0.1.0&quot;)
        .author(&quot;Hackerman Jones &lt;hckrmnjones@hack.gov&gt;&quot;)
        .about(&quot;Teaches argument parsing&quot;)
        .arg(Arg::with_name(&quot;file&quot;)
                 .short(&quot;f&quot;)
                 .long(&quot;file&quot;)
                 .takes_value(true)
                 .help(&quot;A cool file&quot;))
        .arg(Arg::with_name(&quot;num&quot;)
                 .short(&quot;n&quot;)
                 .long(&quot;number&quot;)
                 .takes_value(true)
                 .help(&quot;Five less than your favorite number&quot;))
        .get_matches();

    let myfile = matches.value_of(&quot;file&quot;).unwrap_or(&quot;input.txt&quot;);
    println!(&quot;The file passed is: {}&quot;, myfile);

    let num_str = matches.value_of(&quot;num&quot;);
    match num_str {
        None =&gt; println!(&quot;No idea what your favorite number is.&quot;),
        Some(s) =&gt; {
            match s.parse::&lt;i32&gt;() {
                Ok(n) =&gt; println!(&quot;Your favorite number must be {}.&quot;, n + 5),
                Err(_) =&gt; println!(&quot;That's not a number! {}&quot;, s),
            }
        }
    }
}
</code></pre></pre>
<h1><a class="header" href="#a-hrefhttprosettacodeorgrosetta-codea" id="a-hrefhttprosettacodeorgrosetta-codea"><a href="http://rosettacode.org">Rosetta Code</a></a></h1>
<p><a href="http://rosettacode.org">Rosetta Code</a> is a list of problems/solutions
written is basically every programming language under the
sun.</p>
<ul>
<li><a href="samples/./samples/rosetta/100_doors.html">100 Doors</a></li>
<li><a href="samples/./samples/rosetta/100_prisoners.html">100 Prisoners</a></li>
<li><a href="samples/./samples/rosetta/15_puzzle_game.html">15 Puzzle Game</a></li>
<li><a href="samples/./samples/rosetta/15_puzzle_solver.html">15 puzzle solver</a></li>
</ul>
<h1><a class="header" href="#a-hrefhttprosettacodeorgwiki100_doorsrust100-doorsa" id="a-hrefhttprosettacodeorgwiki100_doorsrust100-doorsa"><a href="http://rosettacode.org/wiki/100_doors#Rust">100 Doors</a></a></h1>
<p>This my first foray into writing a simple algorithm in Rust.</p>
<h2><a class="header" href="#lessons-learned" id="lessons-learned">Lessons Learned</a></h2>
<ol>
<li>Don't use <code>vec!</code> for a fixed size list (array)
<code>let mut doors = vec![false; 100];</code>
<code>let mut doors = [false; 100];</code></li>
<li>Translate a bool into a string - nice!:
a. println!(&quot;{}&quot;, if d {&quot;open&quot;} else {&quot;closed&quot;});</li>
<li><code>for (i, &amp;is_open) in door_open.iter().enumerate()</code>
a. Maybe this is faster/more idiomatic than my approach - but less readable? Based on comments perhaps this approach is faster due to printing being a bottleneck. I don't understand.</li>
<li>Rust is (at least) two languages bundled into one:
a. A procedural and a declarative (functional) language
b. The procedural language is easier to understand for this problem.
c. The procedural language requires you become familiar with a limited set of verbs: let, for, if, while etc.
d. The declarative language requires you become familiar with many more verbs: filter, iterate, enumerate, map, last, any, find, skip, nth, take, take_while, etc.
e. The magic of Rust is that you can get similar (sometimes better) performance in Declarative versus Procedural.
f. To be a good Rust programmer, you should become familiar with both styles of programming. In the longer term, it is probably better to prefer the Declarative style.
g. In many cases, parallelization can be trivially achieved in the Declarative style.</li>
</ol>
<h2><a class="header" href="#my-soution" id="my-soution">My Soution</a></h2>
<p>First roseatta code problem attempt in Rust (not looking at solution)...</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    let mut doors = vec![false; 100];
    for i in 0..100 {
        let mut d = i;
        while d &lt; 100 {
            doors[d] = !doors[d];
            d += i + 1;
        }
    }
    for d in 0..100 {
        println!(&quot; {}/{}&quot;, d + 1, doors[d]);
    }
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#official-solution" id="official-solution">Official Solution</a></h2>
<h3><a class="header" href="#procedural" id="procedural">Procedural</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    let mut door_open = [false; 100];
    for pass in 1..101 {
        let mut door = pass;
        while door &lt;= 100 {
            door_open[door - 1] = !door_open[door - 1];
            door += pass;
        }
    }
    for (i, &amp;is_open) in door_open.iter().enumerate() {
        println!(&quot;Door {} is {}.&quot;, i + 1, if is_open {&quot;open&quot;} else {&quot;closed&quot;});
    }
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>100 bools initialized to false</li>
<li>for 100 passes 
<ul>
<li>walk until past 100 doors 
<ul>
<li>start at door# = pass#</li>
<li>toggle state of door</li>
<li>skip forward pass# number of doors</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#declarative" id="declarative">Declarative</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    let doors = vec![false; 100]
       .iter_mut()
       .enumerate()
       .map(|(door, door_state)|
         (1..100).into_iter().filter(|pass| door % pass == 0)
         .map(|_| { *door_state = !*door_state; *door_state })
         .last()
         .unwrap()
        )
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!(&quot;{:?}&quot;, doors);
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>100 bools initialized to false</li>
<li>mutable iterator</li>
<li>enumerate to give (index, value) (i.e door, door_state)
<ul>
<li>iterate 100 times for each (door, door_state)
<ul>
<li>skip unless this pass includes this door state
<ul>
<li>(door number / pass#) divides evenly</li>
</ul>
</li>
<li>toggle the door state (boolean)</li>
<li>this produces a boolean list for this door
<ul>
<li>(100 long for door #1; 1 long for door #100)</li>
</ul>
</li>
</ul>
</li>
<li>take the last entry in this list
<ul>
<li>this is the final state for the door</li>
</ul>
</li>
<li>because lists can be empty and there may not be a last element, so last() needs to return an Option&lt;T&gt; not a T.</li>
<li>unwrap() the Option&lt;T&gt; into a T
<ul>
<li>note: you are guaranteed to have at least one element becuase you visited every door, so the unwrap cannot panic.</li>
</ul>
</li>
</ul>
</li>
<li>collect the results for all doors</li>
</ul>
<p><a href="http://rosettacode.org/wiki/100_prisoners#Rust"># 100 Prisoners</a></p>
<ul>
<li>
<p>100 prisoners are individually numbered 1 to 100</p>
</li>
<li>
<p>A room having a cupboard of 100 opaque drawers numbered 1 to 100, that cannot be seen from outside.</p>
</li>
<li>
<p>Cards numbered 1 to 100 are placed randomly, one to a drawer, and the drawers all closed; at the start.</p>
</li>
<li>
<p>Prisoners start outside the room</p>
<ul>
<li>They can decide some strategy before any enter the room.</li>
<li>Prisoners enter the room one by one, can open a drawer, inspect the card number in the drawer, then close the drawer.</li>
<li>A prisoner can open no more than 50 drawers.</li>
<li>A prisoner tries to find his own number.</li>
<li>A prisoner finding his own number is then held apart from the others.</li>
</ul>
</li>
<li>
<p>If all 100 prisoners find their own numbers then they will all be pardoned. If any don't then all sentences stand. </p>
</li>
</ul>
<details><summary>Pseudo Code</summary>
<ol>
<li>create boxes vec containing numbers 1 thru 100
<ul>
<li>These numbers are the prison numbers</li>
<li>hint: this is a collected range</li>
</ul>
</li>
<li>Prisoner guess: given the boxes and a prisoner number
<ol>
<li>create guesses vec containing numbers 1 thru 100</li>
<li>shuffle guesses</li>
<li>for first 50 guesses
<ol>
<li>return if any box corresponding to the guess contains a number matching prisoner number</li>
</ol>
</li>
</ol>
</li>
<li>Perform trial:
<ol>
<li>shuffle the boxes</li>
<li>for all prisoners numbers 0 thru 100
<ul>
<li>Prisoner guess</li>
</ul>
</li>
</ol>
</li>
<li>Peform 1000 trials
<ol>
<li>filter successes
<ol>
<li>Perform trial</li>
</ol>
</li>
<li>count successes</li>
</ol>
</li>
</ol>
</details><details><summary>Solution</summary>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let boxes = (1u8..101u8).collect();
fn prisoner_guess(boxes: mut &amp;[u8], prisoner_number) -&gt; bool {
    let guesses = {
        boxes.shuffle()
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#official-solution-1" id="official-solution-1">Official Solution</a></h2>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;
 
use rand::prelude::*;
 
// Do a full run of checking boxes in a random order for a single prisoner
fn check_random_boxes(prisoner: u8, boxes: &amp;[u8]) -&gt; bool {
    let checks = {
        let mut b: Vec&lt;u8&gt; = (1u8..=100u8).collect();
        b.shuffle(&amp;mut rand::thread_rng());
        b
    };
    checks.into_iter().take(50).any(|check| boxes[check as usize - 1] == prisoner)
}
 
// Do a full run of checking boxes in the optimized order for a single prisoner
fn check_ordered_boxes(prisoner: u8, boxes: &amp;[u8]) -&gt; bool {
    let mut next_check = prisoner;
    (0..50).any(|_| {
        next_check = boxes[next_check as usize - 1];
        next_check == prisoner
    })
}
 
fn main() {
    let mut boxes: Vec&lt;u8&gt; = (1u8..=100u8).collect();
 
    let trials = 100000;
 
    let ordered_successes = (0..trials).filter(|_| {
        boxes.shuffle(&amp;mut rand::thread_rng());
        (1u8..=100u8).all(|prisoner| check_ordered_boxes(prisoner, &amp;boxes))
    }).count();
 
    let random_successes = (0..trials).filter(|_| {
        boxes.shuffle(&amp;mut rand::thread_rng());
        (1u8..=100u8).all(|prisoner| check_random_boxes(prisoner, &amp;boxes))
    }).count();
 
    println!(&quot;{} / {} ({:.02}%) successes in ordered&quot;, ordered_successes, trials, ordered_successes as f64 * 100.0 / trials as f64);
    println!(&quot;{} / {} ({:.02}%) successes in random&quot;, random_successes, trials, random_successes as f64 * 100.0 / trials as f64);
 
}
</code></pre></pre>
</details>
<h1><a class="header" href="#15-puzzle-game" id="15-puzzle-game">15 Puzzle Game</a></h1>
<details><summary>Pseudo Code</summary>
Define enums for Action, Direction, and Cell types
Define a Board type
Define an EMPTY constant
Define a struct for the P15 game
<pre><code>- Constructor
- fn is_valid(mut board: Board) -&gt; bool {
- find empty cell: return the location of the empty cell
- get_moves return a hash map of direction: cell
- play given a Direction
- fn is_complete(&amp;self) -&gt; bool {
</code></pre>
<ul>
<li>Implement Display trait for P15
<ul>
<li>write fmt function
fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {</li>
</ul>
</li>
</ul>
<p>Implement user interface for function to ask user to
Move a cell up/down/left/right Or Quit
Use get_move to see what Cell can move in what direction
Perform the move</p>
</details><details><summary>Solution</summary>
<pre><pre class="playpen"><code class="language-rust editable">extern crate rand;

use std::collections::HashMap;
use std::fmt;
 
use rand::Rng;
use rand::seq::SliceRandom;
 
#[derive(Copy, Clone, PartialEq, Debug)]
enum Cell {
    Card(usize),
    Empty,
}
 
#[derive(Eq, PartialEq, Hash, Debug)]
enum Direction {
    Up,
    Down,
    Left,
    Right,
}
 
enum Action {
    Move(Direction),
    Quit,
}
 
type Board = [Cell; 16];
const EMPTY: Board = [Cell::Empty; 16];
 
struct P15 {
    board: Board,
}
 
impl P15 {
    fn new() -&gt; Self {
        let mut board = EMPTY;
        for (i, cell) in board.iter_mut().enumerate().skip(1) {
            *cell = Cell::Card(i);
        }
 
        let mut rng = rand::thread_rng();
 
        board.shuffle(&amp;mut rng);
        if !Self::is_valid(board) {
            // random swap
            let i = rng.gen_range(0, 16);
            let mut j = rng.gen_range(0, 16);
            while j == i {
                j = rng.gen_range(0, 16);
            }
            board.swap(i, j);
        }
 
        Self { board }
    }
 
    fn is_valid(mut board: Board) -&gt; bool {
        // TODO: optimize
        let mut permutations = 0;
 
        let pos = board.iter().position(|&amp;cell| cell == Cell::Empty).unwrap();
 
        if pos != 15 {
            board.swap(pos, 15);
            permutations += 1;
        }
 
        for i in 1..16 {
            let pos = board
                .iter()
                .position(|&amp;cell| match cell {
                    Cell::Card(value) if value == i =&gt; true,
                    _ =&gt; false,
                })
                .unwrap();
 
            if pos + 1 != i {
                board.swap(pos, i - 1);
                permutations += 1;
            }
        }
 
        permutations % 2 == 0
    }
 
    fn get_empty_position(&amp;self) -&gt; usize {
        self.board.iter().position(|&amp;c| c == Cell::Empty).unwrap()
    }
 
    fn get_moves(&amp;self) -&gt; HashMap&lt;Direction, Cell&gt; {
        let mut moves = HashMap::new();
        let i = self.get_empty_position();
 
        if i &gt; 3 {
            moves.insert(Direction::Up, self.board[i - 4]);
        }
        if i % 4 != 0 {
            moves.insert(Direction::Left, self.board[i - 1]);
        }
        if i &lt; 12 {
            moves.insert(Direction::Down, self.board[i + 4]);
        }
        if i % 4 != 3 {
            moves.insert(Direction::Right, self.board[i + 1]);
        }
        moves
    }
 
    fn play(&amp;mut self, direction: &amp;Direction) {
        let i = self.get_empty_position();
        // This is safe because &lt;code&gt;ask_action&lt;/code&gt; only returns legal moves
        match *direction {
            Direction::Up =&gt; self.board.swap(i, i - 4),
            Direction::Left =&gt; self.board.swap(i, i - 1),
            Direction::Right =&gt; self.board.swap(i, i + 1),
            Direction::Down =&gt; self.board.swap(i, i + 4),
        };
    }
 
    fn is_complete(&amp;self) -&gt; bool {
        self.board.iter().enumerate().all(|(i, &amp;cell)| match cell {
            Cell::Card(value) =&gt; value == i + 1,
            Cell::Empty =&gt; i == 15,
        })
    }
}
 
impl fmt::Display for P15 {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        r#try!(write!(f, &quot;+----+----+----+----+\n&quot;));
        for (i, &amp;cell) in self.board.iter().enumerate() {
            match cell {
                Cell::Card(value) =&gt; r#try!(write!(f, &quot;| {:2} &quot;, value)),
                Cell::Empty =&gt; r#try!(write!(f, &quot;|    &quot;)),
            }
 
            if i % 4 == 3 {
                r#try!(write!(f, &quot;|\n&quot;));
                r#try!(write!(f, &quot;+----+----+----+----+\n&quot;));
            }
        }
        Ok(())
    }
}
 
fn main() {
    let mut p15 = P15::new();
 
    for turns in 1.. {
        println!(&quot;{}&quot;, p15);
        match ask_action(&amp;p15.get_moves()) {
            Action::Move(direction) =&gt; {
                p15.play(&amp;direction);
            }
            Action::Quit =&gt; {
                println!(&quot;Bye !&quot;);
                break;
            }
        }
 
        if p15.is_complete() {
            println!(&quot;Well done ! You won in {} turns&quot;, turns);
            break;
        }
    }
}
 
fn ask_action(moves: &amp;HashMap&lt;Direction, Cell&gt;) -&gt; Action {
    use std::io::{self, Write};
    use Action::*;
    use Direction::*;
 
    println!(&quot;Possible moves:&quot;);
 
    if let Some(&amp;Cell::Card(value)) = moves.get(&amp;Up) {
        println!(&quot;\tU) {}&quot;, value);
    }
    if let Some(&amp;Cell::Card(value)) = moves.get(&amp;Left) {
        println!(&quot;\tL) {}&quot;, value);
    }
    if let Some(&amp;Cell::Card(value)) = moves.get(&amp;Right) {
        println!(&quot;\tR) {}&quot;, value);
    }
    if let Some(&amp;Cell::Card(value)) = moves.get(&amp;Down) {
        println!(&quot;\tD) {}&quot;, value);
    }
    println!(&quot;\tQ) Quit&quot;);
    print!(&quot;Choose your move : &quot;);
    io::stdout().flush().unwrap();
 
    let mut action = String::new();
    io::stdin().read_line(&amp;mut action).expect(&quot;read error&quot;);
    match action.to_uppercase().trim() {
        &quot;U&quot; if moves.contains_key(&amp;Up) =&gt; Move(Up),
        &quot;L&quot; if moves.contains_key(&amp;Left) =&gt; Move(Left),
        &quot;R&quot; if moves.contains_key(&amp;Right) =&gt; Move(Right),
        &quot;D&quot; if moves.contains_key(&amp;Down) =&gt; Move(Down),
        &quot;Q&quot; =&gt; Quit,
        _ =&gt; {
            println!(&quot;Unknown action: {}&quot;, action);
            ask_action(moves)
        }
    }
}
</code></pre></pre>
</details><h1><a class="header" href="#15-puzzle-solver" id="15-puzzle-solver">15 puzzle solver</a></h1>
<h1><a class="header" href="#linux-environment" id="linux-environment">Linux Environment</a></h1>
<p>Tools and utilities for Linux.</p>
<h1><a class="header" href="#non-rust-utilities" id="non-rust-utilities">Non-Rust Utilities</a></h1>
<h1><a class="header" href="#terminator" id="terminator">Terminator</a></h1>
<h1><a class="header" href="#language-features" id="language-features">Language Features</a></h1>
<h2><a class="header" href="#traits" id="traits">Traits</a></h2>
<p>A trait is a collection of methods defined for an unknown type: Self.
They can access other methods declared in the same trait.
<a href="https://doc.rust-lang.org/rust-by-example/trait.html#traits">RustByExample</a></p>
<ul>
<li>
<p>The owner of a type can implement any traits on that type</p>
</li>
<li>
<p>The owner of a trait can implement that trait on any type</p>
</li>
<li>
<p>you can implement traits you defined on types you didn't define</p>
</li>
<li>
<p>you can implement traits you didn't define on your types you defined</p>
</li>
<li>
<p>But you cannot implement traits you didn’t define on types you didn’t define</p>
</li>
</ul>
<h3><a class="header" href="#traits-versus-interfaces" id="traits-versus-interfaces">Traits versus Interfaces</a></h3>
<p>Unlike interfaces in languages like Java, C# or Scala, new traits
can be implemented for existing types whereas interfaces can only
be implemented for your own classes.</p>
<ul>
<li>The owner of a class can implement any interfaces on that type</li>
<li><span style='color:red'>The owner of an interface <em>cannot</em> implement that
interface on a class they did not define</span> - <span style='color:green'>in Rust you can</span>.</li>
</ul>
<p>A trait is not the same as a C# extension method.</p>
<h1><a class="header" href="#destructors" id="destructors">Destructors</a></h1>
<pre><pre class="playpen"><code class="language-rust editable">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct PrintOnDrop(&amp;'static str);

impl Drop for PrintOnDrop {
    fn drop(&amp;mut self) {
        println!(&quot;{}&quot;, self.0);
    }
}

let mut overwritten = PrintOnDrop(&quot;drops when overwritten&quot;);
letoverwritten = PrintOnDrop(&quot;drops when scope ends&quot;);
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#memory" id="memory">Memory</a></h1>
<h2><a class="header" href="#references" id="references">References</a></h2>
<p>https://stackoverflow.com/questions/30938499/why-is-the-sized-bound-necessary-in-this-trait</p>
<h2><a class="header" href="#passing-arguments-and-returning-values" id="passing-arguments-and-returning-values">Passing Arguments and Returning Values</a></h2>
<ul>
<li>Functions must return a known size of memory.</li>
<li>Functions parameters must be of a known size of memory.</li>
<li>Local variables must be of a known size.</li>
<li>Functions must return a concrete <em>sized</em> type - <strong>unlike other languages</strong>.</li>
<li>A concrete type may be sized or unsized.</li>
<li>Traits are not concrete - their size is unknown.</li>
<li><span style='color:red'>You cannot return Traits</span>.</li>
<li><span style='color:lightblue'>Place Traits in a Box</span>.</li>
<li>A Box is a reference to heap memory.</li>
<li>A reference has a known size - it is a pointer.</li>
<li>Rust prefers code to be explicit if memory is heap or stack.</li>
<li><code>dyn</code> indicates that memory is in the heap.</li>
<li>For a generic function we need to ensure that the arguments are sized.</li>
<li>Rust defaults all generic type parameters to be <code>Sized</code>. So <code>fn generic_fn<T>(x: T) -&gt; T { ... }</code> is the equivalent of <code>fn generic_fn&lt;T: Sized&gt;(x: T) -&gt; T { ... }</code>. But <span style='color:yellow'>you may not want that</span>. So <code>fn generic_fn&lt;T: ?Sized&gt;(x: &amp;T) -&gt; u32 { ... }</code> allows you to call generic_fn(&quot;abc&quot;) where <code>T == str</code> which is an unsized type <code>str</code> but the argument is <code>&amp;T</code> which is sized so all is good.</li>
<li><code>trait</code> has an implicit <code>?Sized</code> bound on <code>Self</code>.</li>
<li><code>trait</code>s can be implemented for sized <strong>and</strong> unsized types. For example, any trait which only contains methods which only take and return Self by reference can be implemented for unsized types.</li>
<li>If you want to return <code>Self</code> by value or accept <code>Self</code> as an argument by value, you need to either bind the trait with <code>Sized</code> or bind the function with <code>Sized</code>: <code>trait A: Sized { ... }</code> or </li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait WithConstructor {
    fn new_with_param(param: usize) -&gt; Self;

    fn new() -&gt; Self
    where
        Self: Sized,
    {
        Self::new_with_param(0)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#trait-objects" id="trait-objects">Trait Objects</a></h1>
<p>If you want to pass a variable to a function which may be of different types at run time, then you can use a trait object.
Alternatively, you can use a generic function will generate a different function for each type that calls the function but a trait object will use the same single function with <em>dynamic dispatch</em> to make any calls to methods of the trait object in the function.</p>
<p>A <em>trait object</em> is a value which we can pass as a parameter to a function and which has as its type a trait as opposed to a concrete type. This means that for all of the trait methods the sizes of the parameters and the return values must be known at compile time. The <em>trait object</em> has an unknown type at compile time because the underlying concrete type is unknown. Lots of types can implement a trait. Some of those types may have a size that changes during execution. For example, if a struct has a String or a Vec, the size of the struct will change as the values are changed. Such a type cannot be placed on the stack and as such it cannot be passed or returned from a function.</p>
<p>A trait is either object safe or not. If a trait is not object safe, it cannot be used to make a trait object. So, being <em>object safe</em> means that we can create a <em>trait object</em> for that Trait.</p>
<p>A trait object must be a reference (or pointer) since it must be a fat pointer containing a pointer to the object data and a pointer to the vtable of the concrete implementation of the functions of the trait.</p>
<p>You have to take the Trait Object by reference or pointer. Whether you use a reference or pointer depends on whether you want to transfer ownership or not.</p>
<p>This will <strong>not compile</strong> because a closure as an unknown size.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 {
    |x| x + 1
}
<span class="boring">}
</span></code></pre></pre>
<p>This will compile: Vec</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// https://stevedonovan.github.io/rustifications/2018/09/08/common-rust-traits.html

use std::string::ToString;

// monomorphic - generic
fn to_string1&lt;T: ToString&gt; (item: &amp;T) -&gt; String {
    item.to_string()
}
// polymorphic - dynamic dispatch
fn to_string2(item: &amp;dyn ToString) -&gt; String {
    item.to_string()
}

println!(&quot;{}&quot;, to_string1(&amp;42));
println!(&quot;{}&quot;, to_string2(&amp;42));
println!(&quot;{}&quot;, to_string1(&amp;&quot;hello&quot;));
println!(&quot;{}&quot;, to_string2(&amp;&quot;hello&quot;));

<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#traits-1" id="traits-1">Traits</a></h1>
<h2><a class="header" href="#object-safety" id="object-safety">Object safety</a></h2>
<p>A trait is <em>object safe</em> if all the methods defined in the trait have the following properties:
- The return type isn’t Self.
- There are no generic type parameters.</p>
<p>For a trait to be <strong>object safe</strong> the underlying concrete type should be referred to by a <code>&amp;self</code> reference and not by <code>self</code> value. A reference is a known size (it is the same size, the size of a pointer, regardless of type) but a value is unknown (it varies depending on the type).</p>
<pre><code>trait T1 {
    fn foo(self); // not object safe,
                  // size of object is unknowable at compile time.
}

trait T2 {
    fn foo(&amp;self); // object safe
}
</code></pre>
<h1><a class="header" href="#iterator" id="iterator">Iterator</a></h1>
<p>You implement an iterator for some custom collection type you define. Maybe you have a company struct which contains a vector
list of employees but the list may contain former employees 
who should not be included in any iteration of the employees. 
So company.employees may be an iterator.
Implementing the Iterator trait means implementing the <code>next</code> function.
You struct will need some index to point to the current location.
You </p>
<pre><pre class="playpen"><code class="language-rust editable">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl&lt;'a&gt; Iterator for Iter&lt;'a&gt; {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // index or some pointer to current item
        while self.index + 1 &lt; self.vec.len() {
            let prev = self.vec[self.index];
            self.index += 1;
            if (*self.f)(prev) {
                return Some(self.vec[self.index]);
            }
        }
        None
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#language-limitations" id="language-limitations">Language Limitations</a></h1>
<h2><a class="header" href="#optional-with-default-parameters" id="optional-with-default-parameters">Optional with default Parameters</a></h2>
<p>There are pros and cons to supporting python equivalent of:</p>
<pre><code class="language-python">def foo(bar=20)
</code></pre>
<p>If we call <code>foo(bar)</code> and bar is None then the default does not
apply and 
Although in this case there is no way not to provide the argument,
you can call foo(None). This has arguable benefit of allowing foo
to be called with an argument with value None and getting the
default, whereas in python you would not know whether the argument
was supplied and if it had None you would need to check for it.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn foo(bar: Option&lt;usize&gt;) {
    let x = bar.unwrap_or(20); //Default value is 20
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#different-signatures" id="different-signatures">Different signatures</a></h2>
<p>C# lets you do this:</p>
<pre><code class="language-C#">public static int Foo(int x = 0) =&gt; 20 * x;
public static int Foo() =&gt; 10;
</code></pre>
<h1><a class="header" href="#best-practices" id="best-practices">Best Practices</a></h1>
<h1><a class="header" href="#miscellaneous" id="miscellaneous">Miscellaneous</a></h1>
<p><code>rustup update</code> to update your version of Rust.
<code>cargo check</code> to see if your crates are up-to-date.</p>
<h3><a class="header" href="#read-a-line-of-input" id="read-a-line-of-input">Read a line of input</a></h3>
<pre><code>  use std::io;
  let mut ans = String::new();
  print!(&quot;Enter answer: &quot;);
  io::stdin().read_line(&amp;mut ans)
  .expect(&quot;Failed to read input&quot;);
</code></pre>
<p><code>cargo doc --open</code> opens the documentation for all your dependencies.</p>
<p><em>Haskell Curry</em> was an American mathematician and logician. </p>
<h3><a class="header" href="#handling-error-cases-with-a-match-expression" id="handling-error-cases-with-a-match-expression">Handling error cases with a <code>match</code> expression</a></h3>
<pre><code>let ans: u32 = match ans.trim().parse() { 
    Ok(num) =&gt; num,
    Err(_) =&gt; 0,
}
</code></pre>
<h3><a class="header" href="#" id=""></a></h3>
<h1><a class="header" href="#glossary" id="glossary">Glossary</a></h1>
<h3><a class="header" href="#a-hrefhttpsdocrust-langorgnomiconindexhtmlrustonomicoma" id="a-hrefhttpsdocrust-langorgnomiconindexhtmlrustonomicoma"><a href="https://doc.rust-lang.org/nomicon/index.html">Rustonomicom</a></a></h3>
<p>A book about writing unsafe code and the inner guts of Rust. |</p>
<h3><a class="header" href="#block" id="block">block</a></h3>
<p>A block is a set of statements enclosed in braces {...}.
A block is an <em>expression</em>.
Before the statements where may be <em>inner attributes</em>.</p>
<h3><a class="header" href="#attributes" id="attributes">attributes</a></h3>
<pre><code>- Built-in attributes
- Macro attributes
- Derive macro helper attributes
- Tool attributes
</code></pre>
<h3><a class="header" href="#inner-attributes" id="inner-attributes">inner attributes</a></h3>
<p>Inner attributes <code>#![allow(unused_variables)]</code> apply to the item containing the attribute. Within a block this means the block may contain unused variables.</p>
<h3><a class="header" href="#outer-attributes" id="outer-attributes">outer attributes</a></h3>
<p>Outer attributes <code>#[test]</code> apply to the <em>thing</em> that follows the attribute.</p>
<h3><a class="header" href="#statement" id="statement">Statement</a></h3>
<p>A statement is a component of a block, which is in turn a component of an <em>outer expression</em> or <em>function</em>. Rust has two kinds of statement: declaration statements and expression statements.</p>
<h3><a class="header" href="#expression-statement" id="expression-statement">expression statement</a></h3>
<p>An <em>expression statement</em> is one that evaluates an <em>expression</em> and ignores its result.</p>
<h3><a class="header" href="#expression" id="expression">expression</a></h3>
<p>An expression may have two roles: it always produces a value, and it may have effects (otherwise known as &quot;side effects&quot;). An expression evaluates to a value, and has effects during evaluation. Many expressions contain sub-expressions (operands).</p>
<h3><a class="header" href="#declaration-statements" id="declaration-statements">Declaration statements</a></h3>
<p>A declaration statement is one that introduces one or more names into the enclosing statement block. The declared names may denote new variables or new items.
The two kinds of declaration statements are item declarations and let statements.</p>
<h3><a class="header" href="#monomorphicpolymorphic" id="monomorphicpolymorphic">monomorphic/polymorphic</a></h3>
<p>A <em>generic</em> function is <em>monomorphic</em>. A function taking a <em>trait object</em> as an argument is <em>polymorphic</em>. 
There is a separate function generated by the compiler for each different type used to call a <em>monomorphic</em> function.
There is just one <em>polymorphic</em> function generated by the compiler for a <em>polymorphic</em> function and <em>static dispatch</em> is employed at runtime to call <em>concrete</em> methods of the abstract <em>trait object</em>.</p>
<p>The <em>monomorphic</em> function is like a C++ templated function.
The <em>polymorphic</em> function is like a C++ base class virtual method or Java interface.
<em>monomorphic</em> is more efficient and can be inlined.</p>
<h3><a class="header" href="#function-pointer" id="function-pointer">function pointer</a></h3>
<p>Function pointer types, written using the fn keyword, refer to a function whose identity is not necessarily known at compile-time.</p>
<pre><pre class="playpen"><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}
fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}
fn main() {
    let answer = do_twice(add_one, 5);
    println!(&quot;The answer is: {}&quot;, answer);
}
</code></pre></pre>
<p>Unlike <em>closures</em>, fn is a <em>type</em> rather than a <em>trait</em>, so we specify fn as the <em>parameter type</em> directly rather than declaring a <em>generic type parameter</em> with one of the Fn traits as a <em>trait bound</em>.</p>
<h3><a class="header" href="#shadowshadowed-variable" id="shadowshadowed-variable">shadow/shadowed variable</a></h3>
<p>A different variable declared with the same name, the first is no longer accessible. The first is not dropped until out of scope. The second declaration does not trigger a drop.</p>
<h3><a class="header" href="#dropdrop-scope" id="dropdrop-scope">drop/drop scope</a></h3>
<p>A variable is dropped when it goes out of scope. This is called the variables <em>drop scope</em>. <em>Drop</em> is the trait which can be implemented to control behavior when dropped.</p>
<h3><a class="header" href="#bindbound" id="bindbound">bind/bound</a></h3>
<p>A variable is <em>bound</em> to a value. |
A module is <em>bound to the current scope</em> via the <code>use</code> statement. <code>use p::q::{r, s}</code> both <em>r</em> and <em>s</em> are bound in the current but not <em>q</em>. Use <code>use p::q::{self, r, s}</code> to also bind <em>q</em> in the current but not <em>q</em>.</p>
<h3><a class="header" href="#enumeration" id="enumeration">Enumeration</a></h3>
<p>An <em>enumeration</em> or <em>enum</em> is a type that can be one of multiple <em>variants</em>.</p>
<h3><a class="header" href="#variant" id="variant">variant</a></h3>
<p>A <em>variant</em> is one of the types an <em>enumeration</em> can take.</p>
<h3><a class="header" href="#crate" id="crate">crate</a></h3>
<p>A crate is a collection of Rust source files. It is what <code>cargo build</code> builds. It can either be a <em>library crate</em> or a <em>binary crate</em> and is specified using a <em>Cargo.toml</em> file.</p>
<h3><a class="header" href="#library-crate" id="library-crate">library crate</a></h3>
<p>A <em>library crate</em> </p>
<h3><a class="header" href="#binary-crate" id="binary-crate">binary crate</a></h3>
<p>A <em>binary crate</em> is an executable.</p>
<h3><a class="header" href="#match-expression" id="match-expression">match expression</a></h3>
<p>A <code>match</code> statement is an expression. It has a value to match against and a number of <em>arms</em> each with a pattern and code to execute if the pattern matches.</p>
<h3><a class="header" href="#expression-1" id="expression-1">expression</a></h3>
<p>An <em>expression</em> is a statement that returns a value.</p>
<h3><a class="header" href="#currying" id="currying">currying</a></h3>
<p>Instead of a function with multiple arguments, you break it down into several functions that each take a single argument and return a function taking a single argument. For the last argument you have a function which takes the final argument and returns the desired value. Each step of the currying process is basically taking a function and substituting the variable with the corresponding argument resulting in a new function. This is cool since you can generate functions at run time and store as objects and pass as arguments etc. Currying allows for easier formal proofs of program correctness.</p>
<h3><a class="header" href="#method" id="method">method</a></h3>
<p>A <em>method</em> is a function defined in the <em>impl</em> block for a type.
A method is called via <code>my_object.method_name(args, ...)</code></p>
<h3><a class="header" href="#semantic-versioning" id="semantic-versioning">Semantic Versioning</a></h3>
<p>Semantic versioning or <em>semver</em> is of the form <strong>x.y.z</strong> where <em>x</em> is the major version for incompatible API updates, <em>y</em> is for backwards compatible functionality updates, and <em>z</em> version when you make backwards compatible bug fixes.</p>
<h3><a class="header" href="#iterator-adapters" id="iterator-adapters">iterator adapters</a></h3>
<p>Functions which take an Iterator and return another Iterator are often called 'iterator adapters', as they're a form of the 'adapter pattern'.</p>
<h3><a class="header" href="#iterator-1" id="iterator-1">iterator</a></h3>
<p>Iterator is a trait with method <code>next</code> which returns <code>Some(Item)</code> as it iterates thru Items and returns <code>None</code> when there are no more items.</p>
<h3><a class="header" href="#method-1" id="method-1">method</a></h3>
<p>Methods are functions attached to objects which have access to the data of the object and its other methods via the <code>self</code> keyword and defined in an <code>impl</code> block.</p>
<p>A method may either be a <code>static</code> or and <code>instance</code> method.</p>
<h3><a class="header" href="#static-method" id="static-method">static method</a></h3>
<p>A static method does not have <code>self</code> as the first parameter.</p>
<h3><a class="header" href="#instance-method" id="instance-method">instance method</a></h3>
<p>An instance method has <code>self</code> as the first parameter.</p>
<h3><a class="header" href="#external-traitexternal-type" id="external-traitexternal-type">external trait/external type</a></h3>
<p>A trait or type that is not defined in the current module. You cannot implement an external trait on an external type but you can implement an external trait on a type you defined and someone
else can implement a trait defined in your module in one of their modules on their own type.</p>
<h2><a class="header" href="#cargo-1" id="cargo-1">cargo</a></h2>
<p>Rust's package manager and build system. <code>cargo --version</code> <code>cargo build</code> <code>cargo run</code> <code>cargo install</code> <code>cargo check</code> <code>cargo new {name}</code></p>
<h2><a class="header" href="#rustup" id="rustup">rustup</a></h2>
<p>The command to upgrade your Rust compiler: <code>rustup update</code></p>
<h2><a class="header" href="#rustc" id="rustc">rustc</a></h2>
<p>The rust compiler, <code>rustc --version</code></p>
<h2><a class="header" href="#fully-qualified-method-calls" id="fully-qualified-method-calls">Fully Qualified Method Calls</a></h2>
<p><code>&lt;str as ToString&gt;::to_string(&quot;hi)</code> is the fully qualified method call for qualified method call <code>ToString::to_string(&quot;hi&quot;)</code> or <code>str::to_string(&quot;hi&quot;)</code>, all of which equate to the simplest form <code>&quot;hi&quot;.to_string()</code></p>
<h2><a class="header" href="#object-safe" id="object-safe">object safe</a></h2>
<p>A trait is object safe if the concrete is reffered by <code>&amp;self</code> reference tnd not by <code>self</code> value.</p>
<pre><code>trait T1 {
    fn foo(self); // not object safe,
                  // size of object is unknowable at compile time.
}

trait T2 {
    fn foo(&amp;self); // object safe
}
</code></pre>
<h2><a class="header" href="#dynamic-dispatch" id="dynamic-dispatch">Dynamic Dispatch</a></h2>
<p>The concrete type of an object is unknown at compile time.</p>
<pre><code>fn foo(o: dyn MyTrait) {  // this will not compile, unknown size
}
</code></pre>
<h2><a class="header" href="#monomorphism" id="monomorphism">Monomorphism</a></h2>
<pre><code>fn foo(o: impl MyTrait) {  // this will compile
}
</code></pre>
<h1><a class="header" href="#troubleshooting" id="troubleshooting">Troubleshooting</a></h1>
<h2><a class="header" href="#published-book-does-not-show-updates" id="published-book-does-not-show-updates">Published book does not show updates</a></h2>
<p>Not sure how long it takes a push to github.com to show up on github.io as pages...but it may take a couple of minutes.</p>
<h2><a class="header" href="#pages-are-not-generated" id="pages-are-not-generated">Pages are not generated</a></h2>
<p>Every page in the book needs to be in the SUMMARY.md in order to be built.</p>
<h2><a class="header" href="#cant-find-crate-for-somecrate" id="cant-find-crate-for-somecrate">Can't find crate for <code>somecrate</code></a></h2>
<p>In Rust Playground <a href="https://play.rust-lang.org">https://play.rust-lang.org</a> only the current <a href="https://github.com/integer32llc/rust-playground/blob/master/compiler/base/Cargo.toml">top 100 crates</a> are available to be used, so you cannot arbitrarily add code and have it run inside your book on the web page.</p>
<h2><a class="header" href="#code-block-will-not-run-in-browser" id="code-block-will-not-run-in-browser">Code block will not run in browser</a></h2>
<p>For example, the <a href="samples/hello_world.html">Hello World</a> will not run when you click the play button.</p>
<p>After a reboot, this problem magically went away. Maybe it is a browser cache issue.</p>
<h1><a class="header" href="#quiz" id="quiz">Quiz</a></h1>
<h2><a class="header" href="#option" id="option">Option</a></h2>
<hr />
<details><summary>Q:  Can you implement a trait on a type you did not define
</summary>A:  <span style='color:green'>Yes!</span> But you cannot implement an external trait (one that you did not define) on an external type (one that you did not define).</details>
<hr />
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=e9cc8920b712c93f0c09c1fe56f831b8">on</a></p>
<p><a href="https://gist.github.com/e9cc8920b712c93f0c09c1fe56f831b8">two</a></p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Aio%3A%3A%7Bself%2C%20Write%7D%3B%0A%0Aprint!(%22this%20%22)%3B%0Aprint!(%22will%20%22)%3B%0Aprint!(%22be%20%22)%3B%0Aprint!(%22on%20%22)%3B%0Aprint!(%22the%20%22)%3B%0Aprint!(%22same%20%22)%3B%0Aprint!(%22line%20%22)%3B%0A%0Aio%3A%3Astdout().flush().unwrap()%3B%0A%0Aprint!(%22this%20string%20has%20a%20newline%2C%20why%20not%20choose%20println!%20instead%3F%5Cn%22)%3B%0A%0Aio%3A%3Astdout().flush().unwrap()%3B%0A%7D">three</a></p>
<details><summary>Q:  How to read a line from stdin?
</summary>A: 
```rust,editable
use std::io;
use std::io::Write;
let mut s = String::new();
print!("Please enter something: ");
io::stdin().read_line(&mut s).expect("Failed to read line from stdin");
println!("You entered: {}", s);
```
</details>
_________________________________________________________
<details><summary>Q:  What happens here upon <code>unwrap</code>?
<pre><pre class="playpen"><code class="language-rust editable">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x:Option&lt;u32&gt; = None.unwrap();
<span class="boring">}
</span></code></pre></pre>
</summary>A:    <span style='color:red'>The program panics!</span> You cannot unwrap() a None, use <code>unwrap_or(...)</code> instead</details>
<hr />
<details><summary>Q:  What is the difference between <code>unwrap_or</code> and <code>unwrap_or_else</code>?
</summary>A:  <code>unwrap_or_else</code> is lazy, <code>unwrap_or</code> is eager.
So unwrap_or_else is for pasing a closure and unwrap_or is for a exiting value.
<pre><pre class="playpen"><code class="language-rust editable">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>assert_eq!(Some(&quot;car&quot;).unwrap_or(&quot;bike&quot;), &quot;car&quot;);
assert_eq!(None.unwrap_or(&quot;bike&quot;), &quot;bike&quot;);
let k = 10;
assert_eq!(Some(4).unwrap_or_else(|| 2 * k), 4);
assert_eq!(None.unwrap_or_else(|| 2 * k), 20);
<span class="boring">}
</span></code></pre></pre>
</details>
<h1><a class="header" href="#references-1" id="references-1">References</a></h1>
<ul>
<li><a href="https://doc.rust-lang.org/book/title-page.html">Rust Book</a></li>
<li><a href="https://rust-lang-nursery.github.io/rust-cookbook/">Rust Cookbook</a></li>
<li><a href="https://play.rust-lang.org">Rust Playground</a></li>
<li><a href="https://www.tutorialspoint.com/rust/index.htm">Rust Tutorial</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example">Rust By Example</a></li>
<li><a href="https://nikolaivazquez.com/rust-workshop/#1">Rust Powerpoint</a></li>
</ul>
<h2><a class="header" href="#excercises" id="excercises">Excercises</a></h2>
<ul>
<li><a href="https://projecteuler.net/">Project Euler</a>
<ul>
<li>No solutions, just do these exercises as practice.</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
