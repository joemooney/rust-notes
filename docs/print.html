<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js coal">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Notes</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Notes on learning Rust programming language.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "coal";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('coal')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Readme</a></li><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="edit_book.html"><strong aria-hidden="true">3.</strong> Editing the Book</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="create_book.html"><strong aria-hidden="true">3.1.</strong> Creating a Book</a></li><li class="chapter-item expanded "><a href="mdbook/preprocessor.html"><strong aria-hidden="true">3.2.</strong> mdbook preprocessor</a></li></ol></li><li class="chapter-item expanded "><a href="cargo.html"><strong aria-hidden="true">4.</strong> Cargo</a></li><li class="chapter-item expanded "><a href="crates/crates.html"><strong aria-hidden="true">5.</strong> Crates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="crates/executable-crates/executable-crates.html"><strong aria-hidden="true">5.1.</strong> Executable Crates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="crates/ripgrep.html"><strong aria-hidden="true">5.1.1.</strong> ripgrep</a></li></ol></li><li class="chapter-item expanded "><a href="crates/anymap.html"><strong aria-hidden="true">5.2.</strong> anymap</a></li><li class="chapter-item expanded "><a href="crates/notify.html"><strong aria-hidden="true">5.3.</strong> notify</a></li></ol></li><li class="chapter-item expanded "><a href="github_init.html"><strong aria-hidden="true">6.</strong> Storing on GitHub</a></li><li class="chapter-item expanded "><a href="sample_code.html"><strong aria-hidden="true">7.</strong> Sample Code</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="samples/hello_world.html"><strong aria-hidden="true">7.1.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="samples/rust_cookbook.html"><strong aria-hidden="true">7.2.</strong> Rust Cookbook</a></li><li class="chapter-item expanded "><a href="samples/rosetta.html"><strong aria-hidden="true">7.3.</strong> Rosetta Code</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="samples/rosetta/100_doors.html"><strong aria-hidden="true">7.3.1.</strong> 100 Doors</a></li><li class="chapter-item expanded "><a href="samples/rosetta/100_prisoners.html"><strong aria-hidden="true">7.3.2.</strong> 100 Prisoners</a></li><li class="chapter-item expanded "><a href="samples/rosetta/15_puzzle_game.html"><strong aria-hidden="true">7.3.3.</strong> 15 Puzzle Game</a></li><li class="chapter-item expanded "><a href="samples/rosetta/15_puzzle_solver.html"><strong aria-hidden="true">7.3.4.</strong> 15 puzzle solver</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="linux.html"><strong aria-hidden="true">8.</strong> Linux Environment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="non_rust.html"><strong aria-hidden="true">8.1.</strong> Non-Rust Utilities</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="terminator.html"><strong aria-hidden="true">8.1.1.</strong> Terminator</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="language_features.html"><strong aria-hidden="true">9.</strong> Language Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language_features/destructor.html"><strong aria-hidden="true">9.1.</strong> Destructuror</a></li><li class="chapter-item expanded "><a href="language_features/memory.html"><strong aria-hidden="true">9.2.</strong> Memory</a></li><li class="chapter-item expanded "><a href="language_features/macros.html"><strong aria-hidden="true">9.3.</strong> Macros</a></li><li class="chapter-item expanded "><a href="language_features/traits.html"><strong aria-hidden="true">9.4.</strong> Traits</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language_features/trait_objects.html"><strong aria-hidden="true">9.4.1.</strong> Trait Objects</a></li><li class="chapter-item expanded "><a href="language_features/object_safety.html"><strong aria-hidden="true">9.4.2.</strong> Object Safety</a></li><li class="chapter-item expanded "><a href="language_features/traits/memory.html"><strong aria-hidden="true">9.4.3.</strong> Iterator</a></li></ol></li><li class="chapter-item expanded "><a href="language_features/enums.html"><strong aria-hidden="true">9.5.</strong> Enums</a></li><li class="chapter-item expanded "><a href="language_features/oop.html"><strong aria-hidden="true">9.6.</strong> Object Orientation</a></li></ol></li><li class="chapter-item expanded "><a href="language_comparison.html"><strong aria-hidden="true">10.</strong> Language Comparison</a></li><li class="chapter-item expanded "><a href="best_practices.html"><strong aria-hidden="true">11.</strong> Best Practices</a></li><li class="chapter-item expanded "><a href="miscellaneous.html"><strong aria-hidden="true">12.</strong> Miscellaneous</a></li><li class="chapter-item expanded "><a href="glossary.html"><strong aria-hidden="true">13.</strong> Glossary</a></li><li class="chapter-item expanded "><a href="troubleshooting.html"><strong aria-hidden="true">14.</strong> Troubleshooting</a></li><li class="chapter-item expanded "><a href="quiz.html"><strong aria-hidden="true">15.</strong> Quiz</a></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">16.</strong> References</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="vscode.html"><strong aria-hidden="true">16.1.</strong> vscode</a></li><li class="chapter-item expanded "><a href="tools.html"><strong aria-hidden="true">16.2.</strong> tools</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Notes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-beginners-guide"><a class="header" href="#rust-beginners-guide">Rust Beginner's Guide</a></h1>
<h3 id="by-joe-mooney"><a class="header" href="#by-joe-mooney"><strong>by Joe Mooney</strong></a></h3>
<p>A beginner's guide to programming in Rust written by a beginner and a beginner's guide to writing an <em>mdbook</em> also by a beginner mdbook user. </p>
<p>This book is generated using a gitbook-like clone called <em>mdbook</em>. The book is stored in github and the book serves the additional purpose of documenting how to create such a book.</p>
<p>Included are commands and instructions for creating a new empty book and how to go about publishing the book on github.</p>
<p>In addition to <code>mdbook</code> there some add-ons to mdbook stored in this repo. There is a preprocessor that makes it easy to generate an interactive quiz.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<ul>
<li><code>cargo install mdbook</code></li>
<li>If you get an error about cannot find crti.o: <code>sudo apt install libc-dev</code></li>
</ul>
<h2 id="viewing-the-book"><a class="header" href="#viewing-the-book">Viewing the Book</a></h2>
<ul>
<li>View the book in github here:  <a href="https://joemooney.github.io/rust-notes/">https://joemooney.github.io/rust-notes/</a></li>
<li>View the book locally: <a href="file:///home/jpm/rust/rust-notes/book/index.html">file:///home/jpm/rust/rust-notes/book/index.html</a></li>
<li>View locally while making updates: <code>mdbook watch --open</code></li>
</ul>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<ul>
<li>document lessons learned in Rust from a beginner's perspective.</li>
<li>create a template and supporting scripts for writing similarly layed out books on any subject.</li>
</ul>
<h2 id="layout-of-book-repo"><a class="header" href="#layout-of-book-repo">Layout of Book repo</a></h2>
<ul>
<li>The md directory contains the book</li>
<li>A README.md at the root level which is synced with a copy in the md folder</li>
<li>md/SUMMARY.md all pages must be recorded in this file - this is table of contents in the left bar</li>
<li>src/*.rs is where all the example rust code is stored, the md files have references via <code>struct Paddle { hello: f32, }</code> for example.</li>
</ul>
<h2 id="authoring-the-book"><a class="header" href="#authoring-the-book">Authoring the Book</a></h2>
<ul>
<li>Build/View loop: <code>mdbook watch --open</code>
<ul>
<li>Opens the local book in a browser</li>
<li>Then you edit pages in md subdirectory</li>
<li>This will trigger a rebuild upon any change of the book</li>
<li>See the updates on browser with web page refresh.</li>
</ul>
</li>
<li>Just Build/View the book locally: <code>mdbook build --open</code></li>
<li><em>Note</em>: README.md in the root directory of the repo is a copy of md/README.md and you should edit the version in the md directory. <code>publish.sh</code> will copy the newer of either of these to the other, but the watch will not trigger a rebuild unless you edit the md directory version.</li>
<li>Publish to github: <code>./publish.sh</code> shell script will generate and will publish changes to the book to github.</li>
</ul>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<h3 id="mdbook-plus"><a class="header" href="#mdbook-plus">mdbook-plus</a></h3>
<p>Clone, build, and install this repo <code>https://github.com/joemooney/mdbook-plus</code>
This is a mdbook preprocessor that I wrote. I use it for colored text and my quiz feature since I could not find an easier way to do these things.
If you get a WARN <code>2021-12-04 14:45:30 [WARN] (mdbook::preprocess::cmd): The command wasn't found, is the &quot;plus&quot; preprocessor installed?</code> when you run <code>mdbook build --open</code> it means you have not installed my mdbook helper mdbook-plus
To install clone the repo and then <code>cargo build</code> and <code>cargo install --path .</code></p>
<h2 id="installbootstrap"><a class="header" href="#installbootstrap">Install/Bootstrap</a></h2>
<ul>
<li>Clone the GitHub repo for the book: <a href="https://github.com/joemooney/rust-notes/">https://github.com/joemooney/rust-notes/</a></li>
</ul>
<p>Once opened, the book contains the instructions for
creating a new book, and editing, publishing etc.</p>
<p>The book contents (markdown) is contained in the md directory.
Any time you change contents in the md directory then the <code>mdbook watch --open</code> will detect the change and regenerate the book locally.</p>
<h3 id="publishing"><a class="header" href="#publishing">Publishing</a></h3>
<p>To publish your changes to github run the <code>publish.sh</code> script. Use the <code>-f</code> force option if it reports there are no changes but you really know that there are and want to publish anyhow. Publishing will require access to github. It is best to install the <em>gh</em> command line tool from github <code>https://github.com/cli/cli</code> and then <code>gh auth login</code> and create a SSH login for your account.
Once published then other people will be able to see your book in &lt;your_name&gt;.github.io/&lt;your_repo&gt; in a few minutes. </p>
<h3 id="checking-your-installation"><a class="header" href="#checking-your-installation">Checking your Installation</a></h3>
<h2 id="interactive-code-example-feature"><a class="header" href="#interactive-code-example-feature">Interactive Code Example Feature</a></h2>
<p>When viewing the book, make sure this feature is working so that you can use the interactive editor to run Rust code while reading the book.</p>
<p>Here is an example of embedding a question and answer code block into the book which the reader can edit and run using <em>rust playground</em>:
If you see a '?Q' and '?A' then you have not installed <em>mdbook-plus</em> (see above)</p>
<details><summary>Q: 
What will happen when you run this code? {click on the arrow to reveal the answer}
```rust,editable
#fn main(){
let x:Option<u32> = None.unwrap();
#}
```
</summary>A: 
It panics, because you cannot unwrap a None. 
It is best not to unwrap unless you know there is no possibility of failure.
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><sub><span style='color:gray'><em>Last Updated: 2022-01-14 09:51:42</em></span></sub></p>
<p>This book contains notes from learning Rust and
notes on how this book was put together.</p>
<h2 id="generally-useful-tools"><a class="header" href="#generally-useful-tools">Generally useful tools:</a></h2>
<p>Here are some useful tools:</p>
<ul>
<li>rust
<ul>
<li>cargo
<ul>
<li>mdbook</li>
</ul>
</li>
</ul>
</li>
<li>GitHub
<ul>
<li>GitHub Pages</li>
</ul>
</li>
<li>gt the gitlab command line tool</li>
<li>git</li>
<li>rsync</li>
<li>VS Code
<ul>
<li>Extensions:
<ul>
<li>docs-markdown :star: ⬅️ Alt-M to see help</li>
<li>Git Graph</li>
<li>GitLens</li>
<li>Rust</li>
<li>crates  - thumbs up if cargo.toml dependencies are up-to-date</li>
<li>TabNine</li>
<li>Vim</li>
</ul>
</li>
</ul>
</li>
<li>Firefox
<ul>
<li>Extensions
<ul>
<li>vimium ⬅️ <em>?</em> for help when in browser, navigate in browser like Vim</li>
</ul>
</li>
</ul>
</li>
<li>Linux
<ul>
<li>terminator</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="editing-the-book"><a class="header" href="#editing-the-book">Editing the Book</a></h1>
<ul>
<li>Having <a href="./create_book.html">created the book</a></li>
<li>Run <code>./watch.sh</code></li>
<li>Keep the <code>SUMMARY.md</code> file open in order to add new pages
<ul>
<li>Ctrl + Click will open the editor for a page link</li>
</ul>
</li>
<li>If you edit any file under the <code>md</code> folder you should see the book regenerated in the terminal where the <code>watch.sh</code> is running.
<ul>
<li>The message <code>The mdbook-plus preprocessor not running ...</code> can be ignored.</li>
</ul>
</li>
</ul>
<table>
<tr><th>Markdown</th></tr>
<tr><td>
<pre>
  plantuml
@startuml
autonumber "&lt;b&gt;[0]"
skinparam responseMessageBelowArrow true
title Example Sequence Diagram
<p>Thread1 -&gt; Thread2: Blocking Request
Thread1 &lt;-- Thread2: Response
Thread1 -&gt;&gt; Thread2: Non-Blocking Message
Thread1 -&gt; Thread1: Sometimes I talk to myself</p>
<p>note right
Maybe something you sent on a channel
end note</p>
<p>alt sunny day
Thread1 -[#green]&gt;&gt; Thread2: <strong>green arrow</strong>
else it rained
loop 1000 times
Thread1 -[#blue]&gt;&gt; Thread2: <strong>blue arrow</strong>
end
else it snowed
Thread1 -&gt;&gt; Thread2: //snowing italics//
end</p>
<p>@enduml
</pre></p>
</td></tr>
<tr><th>Generated Image</th></tr>
</td><td>
<object data="mdbook-plantuml-img/da8e5b7d0b16807be040183de4deeaef07157017.svg" type="image/svg+xml" >mdbook-plantuml-img/da8e5b7d0b16807be040183de4deeaef07157017.svg</object>
</td></tr>
</table>
<p><object data="mdbook-plantuml-img/ee6f582f07d6a197e3e892b430b9e33c6bd5b332.svg" type="image/svg+xml" >mdbook-plantuml-img/ee6f582f07d6a197e3e892b430b9e33c6bd5b332.svg</object></p>
<h2 id="supporting-diagrams"><a class="header" href="#supporting-diagrams">Supporting Diagrams</a></h2>
<p><a href="https://plantuml.com/">Plantuml</a> is used to generate supporting diagrams.
Using <a href="https://crates.io/crates/mdbook-plantuml">mdbook-plantuml</a> postprocessor we can use markdown to represent the diagrams and a corresponding image file will be generated upon book generation.</p>
<p><object data="mdbook-plantuml-img/4ea434013d02a291a36350844a16c88ea653a815.svg" type="image/svg+xml" >mdbook-plantuml-img/4ea434013d02a291a36350844a16c88ea653a815.svg</object></p>
<h2 id="book-layout"><a class="header" href="#book-layout">Book Layout</a></h2>
<p><object data="mdbook-plantuml-img/c968f5234ec8682e38c84ce4e5262aa33a0c5453.svg" type="image/svg+xml" >mdbook-plantuml-img/c968f5234ec8682e38c84ce4e5262aa33a0c5453.svg</object></p>
<p><object data="mdbook-plantuml-img/860f0c11d3772e2294117f8760dc0346cd79875f.svg" type="image/svg+xml" >mdbook-plantuml-img/860f0c11d3772e2294117f8760dc0346cd79875f.svg</object></p>
<p><object data="mdbook-plantuml-img/7e85c6a26c72b7c6ff081e7e7511e3b32f47785a.svg" type="image/svg+xml" >mdbook-plantuml-img/7e85c6a26c72b7c6ff081e7e7511e3b32f47785a.svg</object></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-book"><a class="header" href="#create-a-book">Create a Book</a></h1>
<p>Create a markdown book with mdbook crate.
This is the crate used to create the official 
Rust Programming Book.
It is also the crate used to this book.
mdbook allows you to add preprocessors so that you can have your own custom markdown extensions (like I am doing).</p>
<ul>
<li>cargo install mdbook</li>
<li>mkdir mybook</li>
<li>cd mybook</li>
<li>mdbook init</li>
</ul>
<p>An example preprocessor is <a href="https://github.com/badboy/mdbook-toc/blob/master/Cargo.toml">mdbook-toc</a>
This book's git repo include a preprocessor that adds question/answer and other capabilities.
For a Table of Contents, use mdbook-toc.</p>
<p>Preprocessors are powerful, they have access to the entire parsed token tree. This allows for finer grain control over changes.</p>
<p>To publish this book there is a simple shell script the outline of which is:</p>
<pre><code class="language-bash">
url=$(git config --get remote.origin.url | sed 's,git@github.com:,,;s,/,.github.io/,;s,^,https://,;s,.git$,/,')

    lang=shell
    mdbook build                                          &amp;&amp; \
    postprocess                                           &amp;&amp; \
    rsync -avx --delete --info=progress2 ./book/ ./docs/  &amp;&amp;\
    git status                                            &amp;&amp; \
    echo 'git commit -am'                                 &amp;&amp; \
    echo -n &quot;Comment: &quot; &amp;&amp; read comment                   &amp;&amp; \
    git add .                                             &amp;&amp; \
    git commit -am &quot;$comment&quot;                             &amp;&amp; \
    git push                                              &amp;&amp; \
    echo &quot;Published: $url

</code></pre>
<p>There are some more guards such as checking for no git untracked files and no other git uncommitted updates.</p>
<p>As I am editing the book, I have <code>mdbook watch --open</code> running which opens a browser and regenerates the book every time it changes.</p>
<h2 id="preprocessors"><a class="header" href="#preprocessors">Preprocessors</a></h2>
<p>Upon <code>cargo install mdbook-mermaid</code> in <em>book.toml</em> add:</p>
<pre><code class="language-toml">[preprocessor.mermaid]
renderer = [&quot;html&quot;, &quot;epub&quot;]
</code></pre>
<p>Then we go:
stateDiagram
state &quot;Also Cool&quot; as s1
s1: foo/bar
[<em>] --&gt; Cool
Cool --&gt; s1
s1 --&gt; Coolest
Coolest --&gt; [</em>]</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-preprocessor-for-mdbook"><a class="header" href="#custom-preprocessor-for-mdbook">Custom preprocessor for mdbook</a></h1>
<p>The mdbook-plus is a very trivial preprocessor for mdbook which simple does a search and replace.
On its own it takes as stdin markdown text with some additional special markers and converts these substrings to HTML.</p>
<p>I am using it since I want to support features not simply available in markdown:</p>
<p>Here we take a look at the markdown you write looks like before and after going through the preprocessor - the markdown output by the preprocessor is fed into by mdbook to generate the final html for the book (in the <code>book</code> subdirectory) and see how it is rendered.
Note that the custom markers are replaced with html which the mdbook markdown to html leaves as is. 
Also note you can use '[#open_bracket]' instead of brackets etc. from being processed as markdown for the special cases - though you probably will never need to worry about that.</p>
<p>The preprocessing happens as part of <code>mdbook build</code>.
<code>publish.sh</code> will run this and publish the generated book to github.</p>
<h3 id="before-preprocessor-markdown-who-you-write"><a class="header" href="#before-preprocessor-markdown-who-you-write">Before Preprocessor (markdown who you write):</a></h3>
<pre><code>- text color {red}red font{/red} {blue}blue{/blue} {green}green{/green} {yellow}yellow{/yellow} {gray}gray{/gray}&lt;br&gt;
- subscripted text {small}subscript font{/small}
</code></pre>
<h3 id="after-preprocessor"><a class="header" href="#after-preprocessor">After Preprocessor:</a></h3>
<pre><code>- text color   &lt;span style='color:red'&gt;red font&lt;/span&gt; &lt;span style='color:lightblue'&gt;blue&lt;/span&gt; &lt;span style='color:green'&gt;green&lt;/span&gt; &lt;span style='color:yellow'&gt;yellow&lt;/span&gt; &lt;span style='color:gray'&gt;gray&lt;/span&gt;
- subscripted text &lt;sub&gt;subscript font&lt;/sub&gt;
</code></pre>
<h3 id="final-rendering-by-mdbook"><a class="header" href="#final-rendering-by-mdbook">Final Rendering by mdbook:</a></h3>
<ul>
<li>text color   <span style='color:red'>red font</span> <span style='color:lightblue'>blue</span> <span style='color:green'>green</span> <span style='color:yellow'>yellow</span> <span style='color:gray'>gray</span></li>
<li>subscripted text <sub>subscript font</sub></li>
</ul>
<h2 id="questionanswer-blocks"><a class="header" href="#questionanswer-blocks">Question/Answer Blocks</a></h2>
<p>Support collapsable question/answer blocks where the answer is hidden until you click the dropdown arrow.
For this we substitute into the html details tag.</p>
<h3 id="before-preprocessor-markdown-who-you-write-1"><a class="header" href="#before-preprocessor-markdown-who-you-write-1">Before Preprocessor (markdown who you write):</a></h3>
<pre><code>?Q Example question goes
   here until we get to the answer&lt;br&gt;
?A You answer goes here until we get to the end&lt;br&gt;
   but it is hidden so that the reader has a chance&lt;br&gt;
   to think before they reveal the answer&lt;br&gt;
?E
</code></pre>
<h3 id="after-preprocessor-1"><a class="header" href="#after-preprocessor-1">After Preprocessor:</a></h3>
<pre><code>&lt;details&gt;&lt;summary&gt;Q: Example question goes here until we get to the answer ?&lt;/summary&gt;A: You answer goes here until we get to the end but it is hidden so that the reader has a chance to think before they reveal the answer&lt;/details&gt;
</code></pre>
<h3 id="final-rendering-by-mdbook-1"><a class="header" href="#final-rendering-by-mdbook-1">Final Rendering by mdbook:</a></h3>
<details><summary>Q: Example question goes here until we get to the answer ?</summary>A: You answer goes here until we get to the end but it is hidden so that the reader has a chance to think before they reveal the answer</details>
<h2 id="install"><a class="header" href="#install">Install</a></h2>
<p><code>cargo install --path . --bin mdbook-plus</code></p>
<h2 id="escaping"><a class="header" href="#escaping">Escaping</a></h2>
<ul>
<li>The preprocessing is just dumb string replacement. So, if you want literal {red} in your output then you can put a backslash before ending brackets so the text substitution does not match (i.e. {red\} which should show as {red})</li>
<li>You can also put [#open_bracket]red[#close_bracket] and likewise for '[#dash]' for '-', '[#question_mark]' for '?'.</li>
</ul>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<ul>
<li>Since these special markers in the input markdown files are not legitimate for normal markdown, intellisense in VS Code (for example) may flag lines with warnings.</li>
<li>Note: <code>code in backticks</code> does not render correctly inside color blocks.</li>
</ul>
<h2 id="install-1"><a class="header" href="#install-1">Install</a></h2>
<p><code>cargo install --path . --bin mdbook-plus</code></p>
<h2 id="escaping-1"><a class="header" href="#escaping-1">Escaping</a></h2>
<ul>
<li>The preprocessing is just dumb string replacement. So, if you want literal {red} in your output then you can put a backslash before ending brackets so the text substitution does not match (i.e. {red\} which should show as {red})</li>
<li>You can also put [#open_bracket]red[#close_bracket] and likewise for '[#dash]' for '-', '[#question_mark]' for '?'.</li>
</ul>
<h3 id="markdown-with-escaped-characters"><a class="header" href="#markdown-with-escaped-characters">Markdown with escaped characters</a></h3>
<pre><code>[#question_mark\]Q Example question goes
   here until we get to the answer&lt;br&gt;
[#question_mark\]A You answer goes here until we get to the end&lt;br&gt;
   but it is hidden so that the reader has a chance&lt;br&gt;
   to think before they reveal the answer&lt;br&gt;
[#question_mark\]E

</code></pre>
<pre><code>- text color [#open_bracket\]red[#close_bracket\]red font[#open_bracket\]/red[#close_bracket\] [#open_bracket\]blue[#close_bracket\]blue[#open_bracket\]/blue[#close_bracket\] [#open_bracket\]green[#close_bracket\]green[#open_bracket\]/green[#close_bracket\] [#open_bracket\]yellow[#close_bracket\]yellow[#open_bracket\]/yellow[#close_bracket\] [#open_bracket\]gray[#close_bracket\]gray[#open_bracket\]/gray[#close_bracket\]&lt;br&gt;
- subscripted text [#open_bracket\]small[#close_bracket\]subscript font[#open_bracket\]small[#close_bracket\]
</code></pre>
<h2 id="limitations-1"><a class="header" href="#limitations-1">Limitations</a></h2>
<ul>
<li>Since these special markers in the input markdown files are not legitimate for normal markdown, intellisense in VS Code (for example) may flag lines with warnings.</li>
<li>Note: <code>code in backticks</code> does not render correctly inside color blocks.</li>
</ul>
<pre><code>
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo"><a class="header" href="#cargo">Cargo</a></h1>
<ul>
<li>
<p>To create a new project crate:</p>
<ul>
<li><code>cargo new mycrate</code></li>
<li><code>cd mycrate</code></li>
<li>git init .</li>
<li>hub new  (hub is deprecated, github now has a <code>gh</code> command)</li>
</ul>
</li>
<li>
<p>To upgrade all your your existing crates you have installed run <code>cargo install-update -a</code></p>
</li>
</ul>
<p>Say you have an existing directory, an empty git repo.
<br>To turn this into a Rust project you run:</p>
<p><code>cargo init . --bin</code></p>
<p>If you then execute <code>cargo run</code> it will compile and run it, printing out <strong>Hello World!</strong></p>
<h2 id="cargo-add-ons"><a class="header" href="#cargo-add-ons">Cargo Add-ons</a></h2>
<p><code>cargo install cargo-edit</code>
this allows you to <code>cargo add/rm &lt;crate&gt;</code> and <code>cargo upgrade --dry-run</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crates"><a class="header" href="#crates">Crates</a></h1>
<p>Crates are libraries or binaries that are typically stored in <a href="http://crates.io">crates.io</a>
An alterative index that for me is easier to find crates of interest is: <a href="http://lib.rs">lib.rs</a></p>
<p>Below are some crates that I have found useful with associated notes.</p>
<h2 id="coding"><a class="header" href="#coding">Coding</a></h2>
<ul>
<li><a href="https://crates.io/crates/anymap">anymap</a>
<ul>
<li><a href="crates/crates/anymap.html">example</a></li>
</ul>
</li>
</ul>
<p>There are many cool crate executables and the running cargo install to install them is a breeze (installation will take some time depending on the number of dependencies).</p>
<h2 id="subprocessshell"><a class="header" href="#subprocessshell">Subprocess/Shell</a></h2>
<ul>
<li><a href="https://docs.rs/crate/duct/0.13.5">duct</a>
<ul>
<li>This will run <em>shell</em> commands for you and manage stdout/stderr.</li>
<li><a href="crates/crates/duct.html">example</a></li>
</ul>
</li>
</ul>
<h2 id="mdbook-related"><a class="header" href="#mdbook-related">MdBook related</a></h2>
<ul>
<li>cargo install <a href="https://github.com/badboy/mdbook-mermaid">mdbook-mermaid</a>
<ul>
<li>cool flowcharts and other graphs for your book</li>
</ul>
</li>
</ul>
<h2 id="executable-crates"><a class="header" href="#executable-crates">Executable Crates</a></h2>
<ul>
<li>cargo install cargo-upadte
<ul>
<li><a href="https://crates.io/crates/cargo-update">cargo-update</a>
<ul>
<li><a href="crates/crates/executable/cargo-update.html">example</a></li>
</ul>
</li>
<li>then <code>cargo install-update --list</code> will list all the installed executables to check if they are up to date.</li>
<li><code>cargo install-update --all</code> will update all installed executables to check if they are up to date.</li>
</ul>
</li>
<li><a href="https://crates.io/crates/ripgrep">ripgrep</a>
<ul>
<li>better, faster grep</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="executable-crates-1"><a class="header" href="#executable-crates-1">Executable Crates</a></h1>
<p>Executable or Binary Crates are binaries that are typically stored in <a href="http://crates.io">crates.io</a>
and installed via <code>cargo install &lt;crate&gt;</code>.</p>
<p>Below are some executeble crates that I have found useful with associated notes.</p>
<ul>
<li>cargo install cargo-upadte
<ul>
<li><a href="https://crates.io/crates/cargo-update">cargo-update</a>
<ul>
<li><a href="crates/executable-crates/crates/executable/cargo-update.html">example</a></li>
</ul>
</li>
<li>then <code>cargo install-update --list</code> will list all the installed executables to check if they are up to date.</li>
<li><code>cargo install-update --all</code> will update all installed executables to check if they are up to date.</li>
</ul>
</li>
<li><a href="https://crates.io/crates/ripgrep">ripgrep</a>
<ul>
<li>better, faster grep</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ripgrep"><a class="header" href="#ripgrep">ripgrep</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anymap-crate"><a class="header" href="#anymap-crate">AnyMap Crate</a></h1>
<p><a href="https://zsiciarz.github.io/24daysofrust/book/vol1/day9.html">credits</a>
<a href="https://crates.io/crates/anymap">anymap</a></p>
<p>Map a key to a value where the key is a type and the value is an instance of that type.</p>
<ul>
<li>Store configuration data</li>
<li>Singleton</li>
</ul>
<p>Create lots of simple types, for example</p>
<pre><pre class="playground"><code class="language-rust editable">extern crate anymap;

use std::net::Ipv4Addr;
use anymap::AnyMap;

#[derive(Debug)]
enum HostAddress {
    DomainName(String),
    Ip(Ipv4Addr),
}

#[derive(Debug)]
struct Port(u32);

#[derive(Debug)]
struct ConnectionLimit(u32);

let mut config = AnyMap::new();
config.insert(HostAddress::DomainName(&quot;siciarz.net&quot;.to_string()));
config.insert(Port(666));
config.insert(ConnectionLimit(32));
println!(&quot;{:?}&quot;, config.get::&lt;HostAddress&gt;());
println!(&quot;{:?}&quot;, config.get::&lt;Port&gt;());
assert!(config.get::&lt;String&gt;().is_none());
assert!(config.get::&lt;u32&gt;().is_none());
</code></pre></pre>
<p>Here we have types e.g. <strong>Port</strong> instead of having a port being a member of some struct we can have an AnyMap and have Port as one of the keys.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="notify"><a class="header" href="#notify">notify</a></h1>
<h2 id="how-do-i-recursively-watch-file-changes-in-rust"><a class="header" href="#how-do-i-recursively-watch-file-changes-in-rust"><a href="https://stackoverflow.com/questions/55440289/how-do-i-recursively-watch-file-changes-in-rust">How do I recursively watch file changes in Rust?</a></a></h2>
<p>This example watches a directory for changes and upon a change an event is received</p>
<pre><pre class="playground"><code class="language-rust">
use notify::{Watcher, RecursiveMode, watcher};
use std::sync::mpsc::channel;
use std::time::Duration;

fn main() {
    // Create a channel to receive the events.
    let (sender, receiver) = channel();

    // Create a watcher object, delivering debounced events.
    // The notification back-end is selected based on the platform.
    // The Duration is how long after the event that you will
    // receive the notification. If this is too short then you
    // may end up taking an action before the event is complete.
    // For example, if a file is written to you may try something
    // before it is finished writing.
    let mut watcher = watcher(sender, Duration::from_secs(2)).unwrap();

    // Add a path to be watched. All files and directories at that path and
    // below will be monitored for changes.
    watcher.watch(&quot;/path/to/watch&quot;, RecursiveMode::Recursive).unwrap();

    loop {
        match receiver.recv() {
           Ok(event) =&gt; println!(&quot;{:?}&quot;, event),
           Err(e) =&gt; println!(&quot;watch error: {:?}&quot;, e),
        }
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storing-on-github"><a class="header" href="#storing-on-github">Storing on github</a></h1>
<p>Create a repo locally:</p>
<ul>
<li><code>mdbook rust-book</code> ⬅️ this will create the directory with a bare bones book</li>
<li><code>cd rust-book</code></li>
<li><code>git init</code></li>
</ul>
<p>Then I installed <em>hub</em> command to simplify working with github:</p>
<ul>
<li><code>sudo snap install [hub](https://hub.github.com/) --classic</code></li>
<li><code>hub create</code> &gt; [!TIP]
<blockquote>
<p>This will create the repo on GitHub, you will be prompted from user/password first time thru.</p>
</blockquote>
</li>
<li><code>git remote show origin</code></li>
<li><code>git push --set-upstream origin master</code></li>
</ul>
<p>After creating some content for the book and pushing the changes to GitHub,
I then ran <code>mdbook build</code> which generated a <em>book</em> directory.</p>
<ul>
<li><code>mdbook build --open</code></li>
<li>Once you are happy with the changes you can publish.</li>
<li><code>mv book docs</code></li>
<li><code>git add docs</code> ⬅️ this must be the name. It is what GitHub Pages requires.</li>
<li><code>git commit -m 'adding my book for the first time'</code></li>
<li>On GitHub, under <em>Settings</em> for the repo, under <em>GitHub Pages</em> section, I selected <em>Source master branch/docs</em></li>
<li><code>git push</code></li>
<li>The link to your site will be shown as <a href="https://joemooney.github.io/rust-notes/">https://&lt;your_id&gt;.github.io/&lt;your_repo&gt;/</a></li>
<li>After you make changes to the book you can sync the <em>book</em> and <em>docs</em> directories.</li>
<li><code>rsync -avx --delete --info=progress2 ./book/ ./docs/</code></li>
<li><code>git push</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sample-code"><a class="header" href="#sample-code">Sample Code</a></h1>
<p>Here we go through code samples from various sources on the web.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    print!(&quot;Hello World!&quot;);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let number = 5;
    print!(&quot;{}&quot;, number);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable">//TODO: how dow import in an mdbook block of code? use itertools::Itertools;
fn main() {
    let numbers = vec![1,2,3,4,5,6,7,8,9];
    // To use itertools
    // numbers.foreach(|i| print!(&quot;{}&quot;, i));
    for i in numbers {
        print!(&quot;{}&quot;, i);
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-cookbook"><a class="header" href="#rust-cookbook"><a href="https://rust-lang-nursery.github.io/rust-cookbook/">Rust Cookbook</a></a></h1>
<p>The code is all taken from the <a href="https://rust-lang-nursery.github.io/rust-cookbook/">Rust Cookbook</a>, the links are back to the Rust Cookbook. The snippets here are just a condensed version without explanation. Read the Rust Cookbook to understand.</p>
<h2 id="random-numbers"><a class="header" href="#random-numbers"><a href="https://rust-lang-nursery.github.io/rust-cookbook/algorithms/randomness.html#generate-random-numbers">Random Numbers</a></a></h2>
<pre><pre class="playground"><code class="language-rust editable">extern crate rand;

use rand::Rng;

fn main() {
    let mut rng = rand::thread_rng();

    let n1: u8 = rng.gen();
    let n2: u16 = rng.gen();
    println!(&quot;Random u8: {}&quot;, n1);
    println!(&quot;Random u16: {}&quot;, n2);
    println!(&quot;Random u32: {}&quot;, rng.gen::&lt;u32&gt;());
    println!(&quot;Random i32: {}&quot;, rng.gen::&lt;i32&gt;());
    println!(&quot;Random float: {}&quot;, rng.gen::&lt;f64&gt;());
    println!(&quot;Integer: {}&quot;, rng.gen_range(0..10));
    println!(&quot;Float: {}&quot;, rng.gen_range(0.0..10.0));
}
</code></pre></pre>
<h2 id="sorting"><a class="header" href="#sorting"><a href="https://rust-lang-nursery.github.io/rust-cookbook/algorithms/sorting.html">Sorting</a></a></h2>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut vec = vec![1, 5, 10, 2, 15];

    vec.sort();

    assert_eq!(vec, vec![1, 2, 5, 10, 15]);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug, Eq, Ord, PartialEq, PartialOrd)]
struct Person {
    name: String,
    age: u32
}

impl Person {
    pub fn new(name: String, age: u32) -&gt; Self {
        Person {
            name,
            age
        }
    }
}

fn main() {
    let mut people = vec![
        Person::new(&quot;Zoe&quot;.to_string(), 25),
        Person::new(&quot;Al&quot;.to_string(), 60),
        Person::new(&quot;John&quot;.to_string(), 1),
    ];

    // Sort people by derived natural order (Name and age)
    people.sort();

    assert_eq!(
        people,
        vec![
            Person::new(&quot;Al&quot;.to_string(), 60),
            Person::new(&quot;John&quot;.to_string(), 1),
            Person::new(&quot;Zoe&quot;.to_string(), 25),
        ]);

    // Sort people by age
    people.sort_by(|a, b| b.age.cmp(&amp;a.age));

    assert_eq!(
        people,
        vec![
            Person::new(&quot;Al&quot;.to_string(), 60),
            Person::new(&quot;Zoe&quot;.to_string(), 25),
            Person::new(&quot;John&quot;.to_string(), 1),
        ]);

}
</code></pre></pre>
<h2 id="command-line-argument-parsing"><a class="header" href="#command-line-argument-parsing"><a href="https://rust-lang-nursery.github.io/rust-cookbook/cli/arguments.html">Command Line Argument Parsing</a></a></h2>
<pre><pre class="playground"><code class="language-rust editable">use clap::{Arg, App};

fn main() {
    let matches = App::new(&quot;My Test Program&quot;)
        .version(&quot;0.1.0&quot;)
        .author(&quot;Hackerman Jones &lt;hckrmnjones@hack.gov&gt;&quot;)
        .about(&quot;Teaches argument parsing&quot;)
        .arg(Arg::with_name(&quot;file&quot;)
                 .short(&quot;f&quot;)
                 .long(&quot;file&quot;)
                 .takes_value(true)
                 .help(&quot;A cool file&quot;))
        .arg(Arg::with_name(&quot;num&quot;)
                 .short(&quot;n&quot;)
                 .long(&quot;number&quot;)
                 .takes_value(true)
                 .help(&quot;Five less than your favorite number&quot;))
        .get_matches();

    let myfile = matches.value_of(&quot;file&quot;).unwrap_or(&quot;input.txt&quot;);
    println!(&quot;The file passed is: {}&quot;, myfile);

    let num_str = matches.value_of(&quot;num&quot;);
    match num_str {
        None =&gt; println!(&quot;No idea what your favorite number is.&quot;),
        Some(s) =&gt; {
            match s.parse::&lt;i32&gt;() {
                Ok(n) =&gt; println!(&quot;Your favorite number must be {}.&quot;, n + 5),
                Err(_) =&gt; println!(&quot;That's not a number! {}&quot;, s),
            }
        }
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rosetta-code"><a class="header" href="#rosetta-code"><a href="http://rosettacode.org">Rosetta Code</a></a></h1>
<p><a href="http://rosettacode.org">Rosetta Code</a> is a list of problems/solutions
written is basically every programming language under the
sun.</p>
<ul>
<li><a href="samples/./samples/rosetta/100_doors.html">100 Doors</a></li>
<li><a href="samples/./samples/rosetta/100_prisoners.html">100 Prisoners</a></li>
<li><a href="samples/./samples/rosetta/15_puzzle_game.html">15 Puzzle Game</a></li>
<li><a href="samples/./samples/rosetta/15_puzzle_solver.html">15 puzzle solver</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="100-doors"><a class="header" href="#100-doors"><a href="http://rosettacode.org/wiki/100_doors#Rust">100 Doors</a></a></h1>
<p>This my first foray into writing a simple algorithm in Rust.</p>
<h2 id="lessons-learned"><a class="header" href="#lessons-learned">Lessons Learned</a></h2>
<ol>
<li>Don't use <code>vec!</code> for a fixed size list (array)
<code>let mut doors = vec![false; 100];</code>
<code>let mut doors = [false; 100];</code></li>
<li>Translate a bool into a string - nice!:
a. println!(&quot;{}&quot;, if d {&quot;open&quot;} else {&quot;closed&quot;});</li>
<li><code>for (i, &amp;is_open) in door_open.iter().enumerate()</code>
a. Maybe this is faster/more idiomatic than my approach - but less readable? Based on comments perhaps this approach is faster due to printing being a bottleneck. I don't understand.</li>
<li>Rust is (at least) two languages bundled into one:
a. A procedural and a declarative (functional) language
b. The procedural language is easier to understand for this problem.
c. The procedural language requires you become familiar with a limited set of verbs: let, for, if, while etc.
d. The declarative language requires you become familiar with many more verbs: filter, iterate, enumerate, map, last, any, find, skip, nth, take, take_while, etc.
e. The magic of Rust is that you can get similar (sometimes better) performance in Declarative versus Procedural.
f. To be a good Rust programmer, you should become familiar with both styles of programming. In the longer term, it is probably better to prefer the Declarative style.
g. In many cases, parallelization can be trivially achieved in the Declarative style.</li>
</ol>
<h2 id="my-soution"><a class="header" href="#my-soution">My Soution</a></h2>
<p>First roseatta code problem attempt in Rust (not looking at solution)...</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut doors = vec![false; 100];
    for i in 0..100 {
        let mut d = i;
        while d &lt; 100 {
            doors[d] = !doors[d];
            d += i + 1;
        }
    }
    for d in 0..100 {
        println!(&quot; {}/{}&quot;, d + 1, doors[d]);
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="official-solution"><a class="header" href="#official-solution">Official Solution</a></h2>
<h3 id="procedural"><a class="header" href="#procedural">Procedural</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut door_open = [false; 100];
    for pass in 1..101 {
        let mut door = pass;
        while door &lt;= 100 {
            door_open[door - 1] = !door_open[door - 1];
            door += pass;
        }
    }
    for (i, &amp;is_open) in door_open.iter().enumerate() {
        println!(&quot;Door {} is {}.&quot;, i + 1, if is_open {&quot;open&quot;} else {&quot;closed&quot;});
    }
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>100 bools initialized to false</li>
<li>for 100 passes 
<ul>
<li>walk until past 100 doors 
<ul>
<li>start at door# = pass#</li>
<li>toggle state of door</li>
<li>skip forward pass# number of doors</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="declarative"><a class="header" href="#declarative">Declarative</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let doors = vec![false; 100]
       .iter_mut()
       .enumerate()
       .map(|(door, door_state)|
         (1..100).into_iter().filter(|pass| door % pass == 0)
         .map(|_| { *door_state = !*door_state; *door_state })
         .last()
         .unwrap()
        )
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!(&quot;{:?}&quot;, doors);
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>100 bools initialized to false</li>
<li>mutable iterator</li>
<li>enumerate to give (index, value) (i.e door, door_state)
<ul>
<li>iterate 100 times for each (door, door_state)
<ul>
<li>skip unless this pass includes this door state
<ul>
<li>(door number / pass#) divides evenly</li>
</ul>
</li>
<li>toggle the door state (boolean)</li>
<li>this produces a boolean list for this door
<ul>
<li>(100 long for door #1; 1 long for door #100)</li>
</ul>
</li>
</ul>
</li>
<li>take the last entry in this list
<ul>
<li>this is the final state for the door</li>
</ul>
</li>
<li>because lists can be empty and there may not be a last element, so last() needs to return an Option&lt;T&gt; not a T.</li>
<li>unwrap() the Option&lt;T&gt; into a T
<ul>
<li>note: you are guaranteed to have at least one element becuase you visited every door, so the unwrap cannot panic.</li>
</ul>
</li>
</ul>
</li>
<li>collect the results for all doors</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p><a href="http://rosettacode.org/wiki/100_prisoners#Rust"># 100 Prisoners</a></p>
<ul>
<li>
<p>100 prisoners are individually numbered 1 to 100</p>
</li>
<li>
<p>A room having a cupboard of 100 opaque drawers numbered 1 to 100, that cannot be seen from outside.</p>
</li>
<li>
<p>Cards numbered 1 to 100 are placed randomly, one to a drawer, and the drawers all closed; at the start.</p>
</li>
<li>
<p>Prisoners start outside the room</p>
<ul>
<li>They can decide some strategy before any enter the room.</li>
<li>Prisoners enter the room one by one, can open a drawer, inspect the card number in the drawer, then close the drawer.</li>
<li>A prisoner can open no more than 50 drawers.</li>
<li>A prisoner tries to find his own number.</li>
<li>A prisoner finding his own number is then held apart from the others.</li>
</ul>
</li>
<li>
<p>If all 100 prisoners find their own numbers then they will all be pardoned. If any don't then all sentences stand. </p>
</li>
</ul>
<details><summary>Pseudo Code</summary>
<ol>
<li>create boxes vec containing numbers 1 thru 100
<ul>
<li>These numbers are the prison numbers</li>
<li>hint: this is a collected range</li>
</ul>
</li>
<li>Prisoner guess: given the boxes and a prisoner number
<ol>
<li>create guesses vec containing numbers 1 thru 100</li>
<li>shuffle guesses</li>
<li>for first 50 guesses
<ol>
<li>return if any box corresponding to the guess contains a number matching prisoner number</li>
</ol>
</li>
</ol>
</li>
<li>Perform trial:
<ol>
<li>shuffle the boxes</li>
<li>for all prisoners numbers 0 thru 100
<ul>
<li>Prisoner guess</li>
</ul>
</li>
</ol>
</li>
<li>Peform 1000 trials
<ol>
<li>filter successes
<ol>
<li>Perform trial</li>
</ol>
</li>
<li>count successes</li>
</ol>
</li>
</ol>
</details><details><summary>Solution</summary>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let boxes = (1u8..101u8).collect();
fn prisoner_guess(boxes: mut &amp;[u8], prisoner_number) -&gt; bool {
    let guesses = {
        boxes.shuffle()
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="official-solution-1"><a class="header" href="#official-solution-1">Official Solution</a></h2>
<pre><pre class="playground"><code class="language-rust">extern crate rand;
 
use rand::prelude::*;
 
// Do a full run of checking boxes in a random order for a single prisoner
fn check_random_boxes(prisoner: u8, boxes: &amp;[u8]) -&gt; bool {
    let checks = {
        let mut b: Vec&lt;u8&gt; = (1u8..=100u8).collect();
        b.shuffle(&amp;mut rand::thread_rng());
        b
    };
    checks.into_iter().take(50).any(|check| boxes[check as usize - 1] == prisoner)
}
 
// Do a full run of checking boxes in the optimized order for a single prisoner
fn check_ordered_boxes(prisoner: u8, boxes: &amp;[u8]) -&gt; bool {
    let mut next_check = prisoner;
    (0..50).any(|_| {
        next_check = boxes[next_check as usize - 1];
        next_check == prisoner
    })
}
 
fn main() {
    let mut boxes: Vec&lt;u8&gt; = (1u8..=100u8).collect();
 
    let trials = 100000;
 
    let ordered_successes = (0..trials).filter(|_| {
        boxes.shuffle(&amp;mut rand::thread_rng());
        (1u8..=100u8).all(|prisoner| check_ordered_boxes(prisoner, &amp;boxes))
    }).count();
 
    let random_successes = (0..trials).filter(|_| {
        boxes.shuffle(&amp;mut rand::thread_rng());
        (1u8..=100u8).all(|prisoner| check_random_boxes(prisoner, &amp;boxes))
    }).count();
 
    println!(&quot;{} / {} ({:.02}%) successes in ordered&quot;, ordered_successes, trials, ordered_successes as f64 * 100.0 / trials as f64);
    println!(&quot;{} / {} ({:.02}%) successes in random&quot;, random_successes, trials, random_successes as f64 * 100.0 / trials as f64);
 
}
</code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="15-puzzle-game"><a class="header" href="#15-puzzle-game">15 Puzzle Game</a></h1>
<details><summary>Pseudo Code</summary>
Define enums for Action, Direction, and Cell types
Define a Board type
Define an EMPTY constant
Define a struct for the P15 game
<pre><code>- Constructor
- fn is_valid(mut board: Board) -&gt; bool {
- find empty cell: return the location of the empty cell
- get_moves return a hash map of direction: cell
- play given a Direction
- fn is_complete(&amp;self) -&gt; bool {
</code></pre>
<ul>
<li>Implement Display trait for P15
<ul>
<li>write fmt function
fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {</li>
</ul>
</li>
</ul>
<p>Implement user interface for function to ask user to
Move a cell up/down/left/right Or Quit
Use get_move to see what Cell can move in what direction
Perform the move</p>
</details><details><summary>Solution</summary>
<pre><pre class="playground"><code class="language-rust editable">extern crate rand;

use std::collections::HashMap;
use std::fmt;
 
use rand::Rng;
use rand::seq::SliceRandom;
 
#[derive(Copy, Clone, PartialEq, Debug)]
enum Cell {
    Card(usize),
    Empty,
}
 
#[derive(Eq, PartialEq, Hash, Debug)]
enum Direction {
    Up,
    Down,
    Left,
    Right,
}
 
enum Action {
    Move(Direction),
    Quit,
}
 
type Board = [Cell; 16];
const EMPTY: Board = [Cell::Empty; 16];
 
struct P15 {
    board: Board,
}
 
impl P15 {
    fn new() -&gt; Self {
        let mut board = EMPTY;
        for (i, cell) in board.iter_mut().enumerate().skip(1) {
            *cell = Cell::Card(i);
        }
 
        let mut rng = rand::thread_rng();
 
        board.shuffle(&amp;mut rng);
        if !Self::is_valid(board) {
            // random swap
            let i = rng.gen_range(0, 16);
            let mut j = rng.gen_range(0, 16);
            while j == i {
                j = rng.gen_range(0, 16);
            }
            board.swap(i, j);
        }
 
        Self { board }
    }
 
    fn is_valid(mut board: Board) -&gt; bool {
        // TODO: optimize
        let mut permutations = 0;
 
        let pos = board.iter().position(|&amp;cell| cell == Cell::Empty).unwrap();
 
        if pos != 15 {
            board.swap(pos, 15);
            permutations += 1;
        }
 
        for i in 1..16 {
            let pos = board
                .iter()
                .position(|&amp;cell| match cell {
                    Cell::Card(value) if value == i =&gt; true,
                    _ =&gt; false,
                })
                .unwrap();
 
            if pos + 1 != i {
                board.swap(pos, i - 1);
                permutations += 1;
            }
        }
 
        permutations % 2 == 0
    }
 
    fn get_empty_position(&amp;self) -&gt; usize {
        self.board.iter().position(|&amp;c| c == Cell::Empty).unwrap()
    }
 
    fn get_moves(&amp;self) -&gt; HashMap&lt;Direction, Cell&gt; {
        let mut moves = HashMap::new();
        let i = self.get_empty_position();
 
        if i &gt; 3 {
            moves.insert(Direction::Up, self.board[i - 4]);
        }
        if i % 4 != 0 {
            moves.insert(Direction::Left, self.board[i - 1]);
        }
        if i &lt; 12 {
            moves.insert(Direction::Down, self.board[i + 4]);
        }
        if i % 4 != 3 {
            moves.insert(Direction::Right, self.board[i + 1]);
        }
        moves
    }
 
    fn play(&amp;mut self, direction: &amp;Direction) {
        let i = self.get_empty_position();
        // This is safe because `ask_action` only returns legal moves
        match *direction {
            Direction::Up =&gt; self.board.swap(i, i - 4),
            Direction::Left =&gt; self.board.swap(i, i - 1),
            Direction::Right =&gt; self.board.swap(i, i + 1),
            Direction::Down =&gt; self.board.swap(i, i + 4),
        };
    }
 
    fn is_complete(&amp;self) -&gt; bool {
        self.board.iter().enumerate().all(|(i, &amp;cell)| match cell {
            Cell::Card(value) =&gt; value == i + 1,
            Cell::Empty =&gt; i == 15,
        })
    }
}
 
impl fmt::Display for P15 {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        r#try!(write!(f, &quot;+----+----+----+----+\n&quot;));
        for (i, &amp;cell) in self.board.iter().enumerate() {
            match cell {
                Cell::Card(value) =&gt; r#try!(write!(f, &quot;| {:2} &quot;, value)),
                Cell::Empty =&gt; r#try!(write!(f, &quot;|    &quot;)),
            }
 
            if i % 4 == 3 {
                r#try!(write!(f, &quot;|\n&quot;));
                r#try!(write!(f, &quot;+----+----+----+----+\n&quot;));
            }
        }
        Ok(())
    }
}
 
fn main() {
    let mut p15 = P15::new();
 
    for turns in 1.. {
        println!(&quot;{}&quot;, p15);
        match ask_action(&amp;p15.get_moves()) {
            Action::Move(direction) =&gt; {
                p15.play(&amp;direction);
            }
            Action::Quit =&gt; {
                println!(&quot;Bye !&quot;);
                break;
            }
        }
 
        if p15.is_complete() {
            println!(&quot;Well done ! You won in {} turns&quot;, turns);
            break;
        }
    }
}
 
fn ask_action(moves: &amp;HashMap&lt;Direction, Cell&gt;) -&gt; Action {
    use std::io::{self, Write};
    use Action::*;
    use Direction::*;
 
    println!(&quot;Possible moves:&quot;);
 
    if let Some(&amp;Cell::Card(value)) = moves.get(&amp;Up) {
        println!(&quot;\tU) {}&quot;, value);
    }
    if let Some(&amp;Cell::Card(value)) = moves.get(&amp;Left) {
        println!(&quot;\tL) {}&quot;, value);
    }
    if let Some(&amp;Cell::Card(value)) = moves.get(&amp;Right) {
        println!(&quot;\tR) {}&quot;, value);
    }
    if let Some(&amp;Cell::Card(value)) = moves.get(&amp;Down) {
        println!(&quot;\tD) {}&quot;, value);
    }
    println!(&quot;\tQ) Quit&quot;);
    print!(&quot;Choose your move : &quot;);
    io::stdout().flush().unwrap();
 
    let mut action = String::new();
    io::stdin().read_line(&amp;mut action).expect(&quot;read error&quot;);
    match action.to_uppercase().trim() {
        &quot;U&quot; if moves.contains_key(&amp;Up) =&gt; Move(Up),
        &quot;L&quot; if moves.contains_key(&amp;Left) =&gt; Move(Left),
        &quot;R&quot; if moves.contains_key(&amp;Right) =&gt; Move(Right),
        &quot;D&quot; if moves.contains_key(&amp;Down) =&gt; Move(Down),
        &quot;Q&quot; =&gt; Quit,
        _ =&gt; {
            println!(&quot;Unknown action: {}&quot;, action);
            ask_action(moves)
        }
    }
}
</code></pre></pre>
</details><div style="break-before: page; page-break-before: always;"></div><h1 id="15-puzzle-solver"><a class="header" href="#15-puzzle-solver">15 puzzle solver</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-environment"><a class="header" href="#linux-environment">Linux Environment</a></h1>
<p>Tools and utilities for Linux.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="non-rust-utilities"><a class="header" href="#non-rust-utilities">Non-Rust Utilities</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terminator"><a class="header" href="#terminator">Terminator</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language-features"><a class="header" href="#language-features">Language Features</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="destructors"><a class="header" href="#destructors">Destructors</a></h1>
<pre><pre class="playground"><code class="language-rust editable">struct PrintOnDrop(&amp;'static str);

impl Drop for PrintOnDrop {
    fn drop(&amp;mut self) {
        println!(&quot;{}&quot;, self.0);
    }
}

let mut overwritten = PrintOnDrop(&quot;drops when overwritten&quot;);
letoverwritten = PrintOnDrop(&quot;drops when scope ends&quot;);
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory"><a class="header" href="#memory">Memory</a></h1>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<p>https://stackoverflow.com/questions/30938499/why-is-the-sized-bound-necessary-in-this-trait</p>
<h2 id="passing-arguments-and-returning-values"><a class="header" href="#passing-arguments-and-returning-values">Passing Arguments and Returning Values</a></h2>
<ul>
<li>Functions must return a known size of memory.</li>
<li>Functions parameters must be of a known size of memory.</li>
<li>Local variables must be of a known size.</li>
<li>Functions must return a concrete <em>sized</em> type - <strong>unlike other languages</strong>.</li>
<li>A concrete type may be sized or unsized.</li>
<li>Traits are not concrete - their size is unknown.</li>
<li><span style='color:red'>You cannot return Traits</span>.</li>
<li><span style='color:lightblue'>Place Traits in a Box</span>.</li>
<li>A Box is a reference to heap memory.</li>
<li>A reference has a known size - it is a pointer.</li>
<li>Rust prefers code to be explicit if memory is heap or stack.</li>
<li><code>dyn</code> indicates that memory is in the heap.</li>
<li>For a generic function we need to ensure that the arguments are sized.</li>
<li>Rust defaults all generic type parameters to be <code>Sized</code>. So <code>fn generic_fn&lt;T&gt;(x: T) -&gt; T { ... }</code> is the equivalent of <code>fn generic_fn&lt;T: Sized&gt;(x: T) -&gt; T { ... }</code>. But <span style='color:yellow'>you may not want that</span>. So <code>fn generic_fn&lt;T: ?Sized&gt;(x: &amp;T) -&gt; u32 { ... }</code> allows you to call generic_fn(&quot;abc&quot;) where <code>T == str</code> which is an unsized type <code>str</code> but the argument is <code>&amp;T</code> which is sized so all is good.</li>
<li><code>trait</code> has an implicit <code>?Sized</code> bound on <code>Self</code>.</li>
<li><code>trait</code>s can be implemented for sized <strong>and</strong> unsized types. For example, any trait which only contains methods which only take and return Self by reference can be implemented for unsized types.</li>
<li>If you want to return <code>Self</code> by value or accept <code>Self</code> as an argument by value, you need to either bind the trait with <code>Sized</code> or bind the function with <code>Sized</code>: <code>trait A: Sized { ... }</code> or </li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait WithConstructor {
    fn new_with_param(param: usize) -&gt; Self;

    fn new() -&gt; Self
    where
        Self: Sized,
    {
        Self::new_with_param(0)
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros"><a class="header" href="#macros">Macros</a></h1>
<p>References</p>
<ul>
<li>
<p><a href="https://danielkeep.github.io/tlborm/book/index.html">Little Book of Macros</a></p>
</li>
<li>
<p>Rust macros are good since they generally:</p>
<ul>
<li>avoid unintended side-effects</li>
<li>do not result in bizarre error messages</li>
<li>are not simple text substitutions, they must be parseable</li>
<li>are subject to much more rigorous analysis during compilation</li>
<li>are an elegant way to add a lot of power to a program, with limited risk</li>
<li>are well thought out and tightly integrated into the ecosystem </li>
<li>have few detractors within the Rust community</li>
<li>can only expand to what is expected at that position (e.g. expression or type definition)</li>
<li>can never expand to an incomplete or invalid construct (e.g. unbalanced parenthesis). In C you could <code>#define Foo Bar(</code> that is impossible in Rust.</li>
<li>can be recursive (up to 32 levels by default)</li>
<li>are actually a big selling point of the language</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits"><a class="header" href="#traits">Traits</a></h1>
<p>See Also: <a href="language_features/./trait_objects.html">Trait Objects</a>
See Also: <a href="language_features/./object_safety.html">Object Safety</a></p>
<p>Per https://doc.rust-lang.org/rust-by-example/trait.html, a trait is a collection of methods defined for an unknown type: Self. They can access other methods declared in the same trait.</p>
<details><summary>Q: 
Is a trait is type?
</summary>A: 
Yes
</details>
<p><a href="https://stackoverflow.com/questions/26983355/is-there-a-way-to-combine-multiple-traits-in-order-to-define-a-new-trait">Combine multiple traits to for a new trait</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait-objects"><a class="header" href="#trait-objects">Trait Objects</a></h1>
<p>See Also: <a href="language_features/./traits.html">Traits</a></p>
<p>A function that has an argument of <code>&amp;dyn T</code> is a trait object.
Only <a href="language_features/./traits.html">object-safe traits</a> are candidates - this eliminates Traits that have any functions with generic arguments or return types.</p>
<h2 id="why-use-trait-objects"><a class="header" href="#why-use-trait-objects">Why use trait objects?</a></h2>
<ul>
<li>Trait objects allow you have collections of objects that implement the same trait but are of different types.</li>
<li>Smaller binaries (polymorphic dynamic dispatch functions instead of monomorphic static dispatch generic functions)</li>
<li>Apparently, the additional runtime overhead is small.</li>
<li>Increasing your use of Traits is good practice.</li>
</ul>
<h2 id="why-not-use-trait-objects"><a class="header" href="#why-not-use-trait-objects">Why not use trait objects?</a></h2>
<ul>
<li>Trait objects result in slower binaries.</li>
<li>Compiler cannot perform inlining optimizations, so if your function is small and frequently called this may not be preferable.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// https://stevedonovan.github.io/rustifications/2018/09/08/common-rust-traits.html

use std::string::ToString;

// Note the signatures are different but the implementations are the same

// Using an Object Reference (not Trait Object), monomorphic - generic function
fn to_string1&lt;T: ToString&gt; (item: &amp;T) -&gt; String {
    item.to_string()
}
// Using a Trait Object, polymorphic - dynamic dispatch
fn to_string2(item: &amp;dyn ToString) -&gt; String {
    item.to_string()
}

// From the calling side there is no difference, but the code generated is different
println!(&quot;{}&quot;, to_string1(&amp;42));  // uses a one version of function to_string1 expanded for &amp;u32
println!(&quot;{}&quot;, to_string1(&amp;&quot;hello&quot;));  // uses a different version of function to_string1 expanded for &amp;str
println!(&quot;{}&quot;, to_string2(&amp;42));  // uses the only version of function to_string2 passing as a trait object &amp;u32
println!(&quot;{}&quot;, to_string2(&amp;&quot;hello&quot;));  // uses the only version of function to_string2 passing as a trait object &amp;str

<span class="boring">}
</span></code></pre></pre>
<p>Another example of using a Vec of trait objects looks pretty slick.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// https://dev.to/magnusstrale/rust-trait-objects-in-a-vector-non-trivial-4co5

use std::f32::consts::PI;

#[derive(PartialEq)]
struct Circle {
    radius: u32,
}

struct Square {
    side: u32,
}

trait Shape: Any {
    fn box_eq(&amp;self, other: &amp;dyn Any) -&gt; bool;
    fn as_any(&amp;self) -&gt; &amp;dyn Any;    
    fn area(&amp;self) -&gt; u32;
}

impl Shape for Square {
    // boilerplate, same for all impl of Shape
    fn as_any(&amp;self) -&gt; &amp;dyn Any {
        self
    }
    // boilerplate, same for all impl of Shape
    fn box_eq(&amp;self, other: &amp;dyn Any) -&gt; bool {
        other.downcast_ref::&lt;Self&gt;().map_or(false, |a| self == a)
    }
    fn area(&amp;self) -&gt; u32 {
        self.size * self.size
    }
}

impl Shape for Circle {
    // boilerplate, same for all impl of Shape
    fn as_any(&amp;self) -&gt; &amp;dyn Any {
        self
    }
    // boilerplate, same for all impl of Shape
    fn box_eq(&amp;self, other: &amp;dyn Any) -&gt; bool {
        other.downcast_ref::&lt;Self&gt;().map_or(false, |a| self == a)
    }
    fn area(&amp;self) -&gt; u32 {
        self.radius.pow(2) * PI
    }
}

impl PartialEq for Box&lt;dyn Shape&gt; {
    fn eq(&amp;self, other: &amp;Box&lt;dyn Shape&gt;) -&gt; bool {
        self.box_eq(other.as_any())
    }
}

fn do_stuff(objects: Vec&lt;Box&lt;dyn Shape&gt;&gt;) {
    let obj1 = &amp;objects[0];
    let obj2 = &amp;objects[1];
    if obj1 == obj2 { println!(&quot;Equal&quot;); }
}

<span class="boring">}
</span></code></pre></pre>
<p>Here we see a Vec of a Trait type which can contain different types of concrete objects which can be differentiated.</p>
<p>If you want to pass a variable to a function which may be of different types at run time, then you can use a trait object.
Alternatively, you can use a generic function will generate a different function for each type that calls the function but a trait object will use the same single function with <em>dynamic dispatch</em> to make any calls to methods of the trait object in the function.</p>
<p>A <em>trait object</em> is a value which we can pass as a parameter to a function and which has as its type a trait as opposed to a concrete type. This means that for all of the trait methods the sizes of the parameters and the return values must be known at compile time. The <em>trait object</em> has an unknown type at compile time because the underlying concrete type is unknown. Lots of types can implement a trait. Some of those types may have a size that changes during execution. For example, if a struct has a String or a Vec, the size of the struct will change as the values are changed. Such a type cannot be placed on the stack and as such it cannot be passed or returned from a function.</p>
<p>A trait is either object safe or not. If a trait is not object safe, it cannot be used to make a trait object. So, being <em>object safe</em> means that we can create a <em>trait object</em> for that Trait.</p>
<p>A trait object must be a reference (or pointer) since it must be a fat pointer containing a pointer to the object data and a pointer to the vtable of the concrete implementation of the functions of the trait.</p>
<p>You have to take the Trait Object by reference or pointer. Whether you use a reference or pointer depends on whether you want to transfer ownership or not.</p>
<p>This will <strong>not compile</strong> because a closure as an unknown size.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 {
    |x| x + 1
}
<span class="boring">}
</span></code></pre></pre>
<p>This will compile: Vec</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="excercise"><a class="header" href="#excercise">Excercise</a></h2>
<p>Write a function taking a Trait Object for Trait Foo.
Foo trait has a function foo with just <code>&amp;self</code> as argument with no return - it would simply print &quot;I am a Cat&quot; where Cat is a struct that implements the Trait or &quot;I am a Dog&quot; for a Dog.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="object-safety"><a class="header" href="#object-safety">Object safety</a></h2>
<p>Only an <code>object-safe trait</code> can be passed as a <code>trait object</code> parameter to a function.</p>
<p>All parameters to a function must have a known size a.k.a <code>Sized</code>.</p>
<p>Traits are <code>?Sized</code>. They have an unknown size since the sizes may vary for different concrete types.</p>
<p>If a <code>trait method</code> returns <code>Self</code>, then from the perspective of the trait, the method is returning a type of varying size depending on the size of the concrete type.
A function cannot return something of unknown size. 
It is fine to declare such a method for a trait because any concrete type that implements the Trait will need to be <code>Sized</code> or else compiler will know to complain.</p>
<p>But it is not okay to pass a reference to an object of that trait <code>dyn &amp;T</code> as an argument to some other function since that other function may call the method returning <code>Self</code>.</p>
<p>Side Note: Rust does not look at the implementation to see if the method is actually being called - if a parameter is okay to be passed into a function then it should be okay to call any of its methods in the function logic.</p>
<p>) and that size may vary which is not allowed (we need to know how many bytes on the stack to allocate for the return value of a function before we call the function).</p>
<p>So, when a type </p>
<p>A trait is <em>object safe</em> if all the methods defined in the trait have the following properties:
- The return type isn’t Self.
- There are no generic type parameters.</p>
<p>For a trait to be <strong>object safe</strong> the underlying concrete type should be referred to by a <code>&amp;self</code> reference and not by <code>self</code> value. A reference is a known size (it is the same size, the size of a pointer, regardless of type) but a value is unknown (it varies depending on the type).</p>
<pre><code>trait T1 {
    fn foo(self); // not object safe,
                  // size of object is unknowable at compile time.
}

trait T2 {
    fn foo(&amp;self); // object safe
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterator"><a class="header" href="#iterator">Iterator</a></h1>
<p>You implement an iterator for some custom collection type you define. Maybe you have a company struct which contains a vector
list of employees but the list may contain former employees 
who should not be included in any iteration of the employees. 
So company.employees may be an iterator.
Implementing the Iterator trait means implementing the <code>next</code> function.
You struct will need some index to point to the current location.
You </p>
<pre><pre class="playground"><code class="language-rust editable">impl&lt;'a&gt; Iterator for Iter&lt;'a&gt; {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // index or some pointer to current item
        while self.index + 1 &lt; self.vec.len() {
            let prev = self.vec[self.index];
            self.index += 1;
            if (*self.f)(prev) {
                return Some(self.vec[self.index]);
            }
        }
        None
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<details><summary>Q:  Can an Enum have methods?
</summary>A:  Yes
<pre><pre class="playground"><code class="language-rust editable">enum Pill {
   Blue,
   Red,
}
impl Pill {
   fn take(&amp;self) {
   	match self {
         Pill::Blue =&gt; println!(&quot;Welcome to the Matrix!&quot;),
         Pill::Red =&gt; println!(&quot;You are awake, welcome to your nightmare!&quot;),
	}
   	
   }
}
fn main() {
   let c = Pill::Red;
   c.take();
}
</code></pre></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-orientation"><a class="header" href="#object-orientation">Object Orientation</a></h1>
<h2 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h2>
<p>Favor composition over inheritance.</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Person {
    name: String,
    age: u32,
    phone: u64,
}

#[derive(Debug)]
struct Employee {
    person: Person,
    phone: u64,
    id: u32,
}

fn main() {
    let p = Person { name: &quot;John&quot;.to_string(), age:33, phone:3334445555 };
    let e = Employee {person:p, phone:1112223333, id:12345};
    println!(&quot;{:?}&quot;, p);
    println!(&quot;{:?}&quot;, e);
    println!(&quot;{:?}, home phone:{}&quot;, e, e.person.phone);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comparisons-with-other-language"><a class="header" href="#comparisons-with-other-language">Comparisons with Other Language</a></h1>
<h2 id="optional-with-default-parameters"><a class="header" href="#optional-with-default-parameters">Optional with default Parameters</a></h2>
<p>There are pros and cons to supporting python equivalent of:</p>
<pre><code class="language-python">def foo(bar=20)
</code></pre>
<p>If we call <code>foo(bar)</code> and bar is None then the default does not
apply and 
Although in this case there is no way not to provide the argument,
you can call foo(None). This has arguable benefit of allowing foo
to be called with an argument with value None and getting the
default, whereas in python you would not know whether the argument
was supplied and if it had None you would need to check for it.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(bar: Option&lt;usize&gt;) {
    let x = bar.unwrap_or(20); //Default value is 20
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="different-signatures"><a class="header" href="#different-signatures">Different signatures</a></h2>
<p>C# lets you do this:</p>
<pre><code class="language-C#">public static int Foo(int x = 0) =&gt; 20 * x;
public static int Foo() =&gt; 10;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h1>
<ul>
<li>avoid using unwrap() or expect() since they panic. Use only when a panic is unavoidable.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="miscellaneous"><a class="header" href="#miscellaneous">Miscellaneous</a></h1>
<p><code>rustup update</code> to update your version of Rust.
<code>cargo check</code> to see if your crates are up-to-date.</p>
<h3 id="read-a-line-of-input"><a class="header" href="#read-a-line-of-input">Read a line of input</a></h3>
<pre><code>  use std::io;
  let mut ans = String::new();
  print!(&quot;Enter answer: &quot;);
  io::stdin().read_line(&amp;mut ans)
  .expect(&quot;Failed to read input&quot;);
</code></pre>
<p><code>cargo doc --open</code> opens the documentation for all your dependencies.</p>
<p><em>Haskell Curry</em> was an American mathematician and logician. </p>
<h3 id="handling-error-cases-with-a-match-expression"><a class="header" href="#handling-error-cases-with-a-match-expression">Handling error cases with a <code>match</code> expression</a></h3>
<pre><code>let ans: u32 = match ans.trim().parse() { 
    Ok(num) =&gt; num,
    Err(_) =&gt; 0,
}
</code></pre>
<h3 id=""><a class="header" href="#"></a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<h3 id="rustonomicom"><a class="header" href="#rustonomicom"><a href="https://doc.rust-lang.org/nomicon/index.html">Rustonomicom</a></a></h3>
<p>A book about writing unsafe code and the inner guts of Rust. |</p>
<h3 id="block"><a class="header" href="#block">block</a></h3>
<p>A block is a set of statements enclosed in braces {...}.
A block is an <em>expression</em>.
Before the statements where may be <em>inner attributes</em>.</p>
<h3 id="bound"><a class="header" href="#bound">bound</a></h3>
<p>When type is <code>bounded by</code> a capability it must provide that capability if required by any code that has access to variable of that type. </p>
<h3 id="bound-t-static"><a class="header" href="#bound-t-static">bound <code>T: 'static</code></a></h3>
<p>Note: <code>T: 'static</code> includes owned types.
A variable with this capability <em>could</em> be accessible for the lifetime of the program <strong>if that part of the code requires it to be so</strong>. That part of the code may not require it to be accessible for the lifetime of the program and if it owns the variable then it may drop it and the variable would obviously not have had a lifetime for the full duration of the program. </p>
<h3 id="attributes"><a class="header" href="#attributes">attributes</a></h3>
<pre><code>- Built-in attributes
- Macro attributes
- Derive macro helper attributes
- Tool attributes
</code></pre>
<h3 id="inner-attributes"><a class="header" href="#inner-attributes">inner attributes</a></h3>
<p>Inner attributes <code>#![allow(unused_variables)]</code> apply to the item containing the attribute. Within a block this means the block may contain unused variables.</p>
<h3 id="outer-attributes"><a class="header" href="#outer-attributes">outer attributes</a></h3>
<p>Outer attributes <code>#[test]</code> apply to the <em>thing</em> that follows the attribute.</p>
<h3 id="statement"><a class="header" href="#statement">Statement</a></h3>
<p>A statement is a component of a block, which is in turn a component of an <em>outer expression</em> or <em>function</em>. Rust has two kinds of statement: declaration statements and expression statements.</p>
<h3 id="expression-statement"><a class="header" href="#expression-statement">expression statement</a></h3>
<p>An <em>expression statement</em> is one that evaluates an <em>expression</em> and ignores its result.</p>
<h3 id="expression"><a class="header" href="#expression">expression</a></h3>
<p>An expression may have two roles: it always produces a value, and it may have effects (otherwise known as &quot;side effects&quot;). An expression evaluates to a value, and has effects during evaluation. Many expressions contain sub-expressions (operands).</p>
<h3 id="declaration-statements"><a class="header" href="#declaration-statements">Declaration statements</a></h3>
<p>A declaration statement is one that introduces one or more names into the enclosing statement block. The declared names may denote new variables or new items.
The two kinds of declaration statements are item declarations and let statements.</p>
<h3 id="monomorphicpolymorphic"><a class="header" href="#monomorphicpolymorphic">monomorphic/polymorphic</a></h3>
<p>A <em>generic</em> function is <em>monomorphic</em>. A function taking a <em>trait object</em> as an argument is <em>polymorphic</em>. 
There is a separate function generated by the compiler for each different type used to call a <em>monomorphic</em> function.
There is just one <em>polymorphic</em> function generated by the compiler for a <em>polymorphic</em> function and <em>static dispatch</em> is employed at runtime to call <em>concrete</em> methods of the abstract <em>trait object</em>.</p>
<p>The <em>monomorphic</em> function is like a C++ templated function.
The <em>polymorphic</em> function is like a C++ base class virtual method or Java interface.
<em>monomorphic</em> is more efficient and can be inlined.</p>
<h3 id="function-pointer"><a class="header" href="#function-pointer">function pointer</a></h3>
<p>Function pointer types, written using the fn keyword, refer to a function whose identity is not necessarily known at compile-time.</p>
<pre><pre class="playground"><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}
fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}
fn main() {
    let answer = do_twice(add_one, 5);
    println!(&quot;The answer is: {}&quot;, answer);
}
</code></pre></pre>
<p>Unlike <em>closures</em>, fn is a <em>type</em> rather than a <em>trait</em>, so we specify fn as the <em>parameter type</em> directly rather than declaring a <em>generic type parameter</em> with one of the Fn traits as a <em>trait bound</em>.</p>
<h3 id="shadowshadowed-variable"><a class="header" href="#shadowshadowed-variable">shadow/shadowed variable</a></h3>
<p>A different variable declared with the same name, the first is no longer accessible. The first is not dropped until out of scope. The second declaration does not trigger a drop.</p>
<h3 id="dropdrop-scope"><a class="header" href="#dropdrop-scope">drop/drop scope</a></h3>
<p>A variable is dropped when it goes out of scope. This is called the variables <em>drop scope</em>. <em>Drop</em> is the trait which can be implemented to control behavior when dropped.</p>
<h3 id="bindbound"><a class="header" href="#bindbound">bind/bound</a></h3>
<p>A variable is <em>bound</em> to a value. |
A module is <em>bound to the current scope</em> via the <code>use</code> statement. <code>use p::q::{r, s}</code> both <em>r</em> and <em>s</em> are bound in the current but not <em>q</em>. Use <code>use p::q::{self, r, s}</code> to also bind <em>q</em> in the current but not <em>q</em>.</p>
<h3 id="enumeration"><a class="header" href="#enumeration">Enumeration</a></h3>
<p>An <em>enumeration</em> or <em>enum</em> is a type that can be one of multiple <em>variants</em>.</p>
<h3 id="variant"><a class="header" href="#variant">variant</a></h3>
<p>A <em>variant</em> is one of the types an <em>enumeration</em> can take.</p>
<h3 id="crate"><a class="header" href="#crate">crate</a></h3>
<p>Per the book: A crate is tree of modules that produces a library or executable.
A crate is a collection of Rust source files. It is what <code>cargo build</code> builds. It can either be a <em>library crate</em>  which typically has a lib.rs or a <em>binary crate</em> which has a main.rs. If a package has both a main.rs and a lib.rs then you have two crates. A crate is configured using a <em>Cargo.toml</em> file.</p>
<h3 id="library-crate"><a class="header" href="#library-crate">library crate</a></h3>
<p>A <em>library crate</em> </p>
<h3 id="binary-crate"><a class="header" href="#binary-crate">binary crate</a></h3>
<p>A <em>binary crate</em> is an executable.</p>
<h3 id="match-expression"><a class="header" href="#match-expression">match expression</a></h3>
<p>A <code>match</code> statement is an expression. It has a value to match against and a number of <em>arms</em> each with a pattern and code to execute if the pattern matches.</p>
<h3 id="expression-1"><a class="header" href="#expression-1">expression</a></h3>
<p>An <em>expression</em> is a statement that returns a value.</p>
<h3 id="currying"><a class="header" href="#currying">currying</a></h3>
<p>Instead of a function with multiple arguments, you break it down into several functions that each take a single argument and return a function taking a single argument. For the last argument you have a function which takes the final argument and returns the desired value. Each step of the currying process is basically taking a function and substituting the variable with the corresponding argument resulting in a new function. This is cool since you can generate functions at run time and store as objects and pass as arguments etc. Currying allows for easier formal proofs of program correctness.</p>
<h3 id="method"><a class="header" href="#method">method</a></h3>
<p>A <em>method</em> is a function defined in the <em>impl</em> block for a type.
A method is called via <code>my_object.method_name(args, ...)</code></p>
<h3 id="semantic-versioning"><a class="header" href="#semantic-versioning">Semantic Versioning</a></h3>
<p>Semantic versioning or <em>semver</em> is of the form <strong>x.y.z</strong> where <em>x</em> is the major version for incompatible API updates, <em>y</em> is for backwards compatible functionality updates, and <em>z</em> version when you make backwards compatible bug fixes.</p>
<h3 id="iterator-adapters"><a class="header" href="#iterator-adapters">iterator adapters</a></h3>
<p>Functions which take an Iterator and return another Iterator are often called 'iterator adapters', as they're a form of the 'adapter pattern'.</p>
<h3 id="iterator-1"><a class="header" href="#iterator-1">iterator</a></h3>
<p>Iterator is a trait with method <code>next</code> which returns <code>Some(Item)</code> as it iterates thru Items and returns <code>None</code> when there are no more items.</p>
<h3 id="method-1"><a class="header" href="#method-1">method</a></h3>
<p>Methods are functions attached to objects which have access to the data of the object and its other methods via the <code>self</code> keyword and defined in an <code>impl</code> block.</p>
<p>A method may either be a <code>static</code> or and <code>instance</code> method.</p>
<h3 id="static-method"><a class="header" href="#static-method">static method</a></h3>
<p>A static method does not have <code>self</code> as the first parameter.</p>
<h3 id="instance-method"><a class="header" href="#instance-method">instance method</a></h3>
<p>An instance method has <code>self</code> as the first parameter.</p>
<h3 id="external-traitexternal-type"><a class="header" href="#external-traitexternal-type">external trait/external type</a></h3>
<p>A trait or type that is not defined in the current module. You cannot implement an external trait on an external type but you can implement an external trait on a type you defined and someone
else can implement a trait defined in your module in one of their modules on their own type.</p>
<h2 id="cargo-1"><a class="header" href="#cargo-1">cargo</a></h2>
<p>Rust's package manager and build system. <code>cargo --version</code> <code>cargo build</code> <code>cargo run</code> <code>cargo install</code> <code>cargo check</code> <code>cargo new {name}</code></p>
<h2 id="package"><a class="header" href="#package">package</a></h2>
<p>Per the book: A package is one or more crates that provide a set of functionality. There can be at most one library and any number of binary crates in the package. Each file in src/bin is a separate binary crate.</p>
<h2 id="rustup"><a class="header" href="#rustup">rustup</a></h2>
<p>The command to upgrade your Rust compiler: <code>rustup update</code></p>
<h2 id="rustc"><a class="header" href="#rustc">rustc</a></h2>
<p>The rust compiler, <code>rustc --version</code></p>
<h2 id="fully-qualified-method-calls"><a class="header" href="#fully-qualified-method-calls">Fully Qualified Method Calls</a></h2>
<p><code>&lt;str as ToString&gt;::to_string(&quot;hi)</code> is the fully qualified method call for qualified method call <code>ToString::to_string(&quot;hi&quot;)</code> or <code>str::to_string(&quot;hi&quot;)</code>, all of which equate to the simplest form <code>&quot;hi&quot;.to_string()</code></p>
<h2 id="object-safe"><a class="header" href="#object-safe">object safe</a></h2>
<p>A trait is object safe if the concrete is reffered by <code>&amp;self</code> reference tnd not by <code>self</code> value.</p>
<pre><code>trait T1 {
    fn foo(self); // not object safe,
                  // size of object is unknowable at compile time.
}

trait T2 {
    fn foo(&amp;self); // object safe
}
</code></pre>
<h2 id="dynamic-dispatch"><a class="header" href="#dynamic-dispatch">Dynamic Dispatch</a></h2>
<p>The concrete type of an object is unknown at compile time.</p>
<pre><code>fn foo(o: dyn MyTrait) {  // this will not compile, unknown size
}
</code></pre>
<h2 id="monomorphism"><a class="header" href="#monomorphism">Monomorphism</a></h2>
<pre><code>fn foo(o: impl MyTrait) {  // this will compile
}
</code></pre>
<h2 id="use"><a class="header" href="#use">use</a></h2>
<p>The use keyword as in <code>use x::y::z</code> brings public items into scope. If z contains items (e.g. x::y::z::foo) then they can be refereced like <code>z::foo</code>, if z is an item (say an enum or struct) then it can be accessed using just <code>z</code> and not using <code>x::y::z</code>. You don't need to have a <code>use</code> statement. You can access any item that your package knows about using a full path in the code (e.g x::y::z::foo())</p>
<h2 id="pub-use"><a class="header" href="#pub-use">pub use</a></h2>
<p>The <code>pub</code> in front of the <code>use</code> <strong>reexports</strong> the items from whatever you are using to appear as they are defined within this module. For example, <code>pub use x::y::Foo</code> in module m, means that code that has a <code>use m</code> can use m::Foo instead of using x::y::Foo.</p>
<h2 id="module"><a class="header" href="#module">module</a></h2>
<p>A <strong>module</strong> is a namespace in which your items can be either <code>public</code> or <code>private</code>. A module named <code>xyz</code> is defined in one of three ways:</p>
<ul>
<li>a <code>mod xyz {...}</code> block</li>
<li>a file <code>xyx.rs</code> that is imported into your crate via a <code>mod xzy;</code> statement</li>
<li>a subdirectory named <code>xyz</code> that contains a <code>mod.rs</code> file, likewise imported into your crate via a <code>mod xyz;</code> statement.
Child modules can use <code>private</code> parent modules items but not vice-versa.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h1>
<h2 id="published-book-does-not-show-updates"><a class="header" href="#published-book-does-not-show-updates">Published book does not show updates</a></h2>
<p>Not sure how long it takes a push to github.com to show up on github.io as pages...but it may take a couple of minutes.</p>
<h2 id="pages-are-not-generated"><a class="header" href="#pages-are-not-generated">Pages are not generated</a></h2>
<p>Every page in the book needs to be in the SUMMARY.md in order to be built.</p>
<h2 id="cant-find-crate-for-somecrate"><a class="header" href="#cant-find-crate-for-somecrate">Can't find crate for <code>somecrate</code></a></h2>
<p>In Rust Playground <a href="https://play.rust-lang.org">https://play.rust-lang.org</a> only the current <a href="https://github.com/integer32llc/rust-playground/blob/master/compiler/base/Cargo.toml">top 100 crates</a> are available to be used, so you cannot arbitrarily add code and have it run inside your book on the web page.</p>
<h2 id="code-block-will-not-run-in-browser"><a class="header" href="#code-block-will-not-run-in-browser">Code block will not run in browser</a></h2>
<p>For example, the <a href="samples/hello_world.html">Hello World</a> will not run when you click the play button.</p>
<p>After a reboot, this problem magically went away. Maybe it is a browser cache issue.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quiz"><a class="header" href="#quiz">Quiz</a></h1>
<h2 id="option"><a class="header" href="#option">Option</a></h2>
<hr />
<details><summary>Q:  Can you implement a trait on a type you did not define
</summary>A:  <span style='color:green'>Yes!</span> But you cannot implement an external trait (one that you did not define) on an external type (one that you did not define).</details>
<hr />
<details><summary>Q:  Including code</summary>A: 
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=e9cc8920b712c93f0c09c1fe56f831b8">one</a></p>
<p><a href="https://gist.github.com/e9cc8920b712c93f0c09c1fe56f831b8">two</a></p>
<p>Here is a anchor1:</p>
<pre><code class="language-rust no_run noplayground">struct Paddle {
    hello: f32,
}
</code></pre>
<p>Here is a anchor2:</p>
<pre><code class="language-rust no_run noplayground">impl System for MySystem { 
    fn foo() {
        println!(&quot;bar&quot;);
    }
 }
</code></pre>
<p>This is the anchor3.</p>
<pre><code class="language-rust no_run noplayground">/* I think I was playing around with a vscode anchor extension */

struct Paddle {
    hello: f32,
}

impl System for MySystem { 
    fn foo() {
        println!(&quot;bar&quot;);
    }
 }

</code></pre>
<script src="https://gist.github.com/joemooney/815626d5cd658d191d10ae48d4803047.js" data-gist-hide-line-numbers="true"></script>
</details>
<details><summary>Q:  How to read a line from stdin?
</summary>A: 
<pre><pre class="playground"><code class="language-rust editable">// this does not work in playground since the stdin fails
use std::io;
use std::io::Write;
fn main() {
    let mut s = String::new();
    print!(&quot;Please enter something: &quot;);
    io::stdin().read_line(&amp;mut s).expect(&quot;Failed to read line from stdin&quot;);
    println!(&quot;\nYou entered: &lt;&lt;{}&gt;&gt;&quot;, s);
}
</code></pre></pre>
</details>
_________________________________________________________
<details><summary>Q:  What happens here upon <code>unwrap</code>?
<pre><pre class="playground"><code class="language-rust editable">let x:Option&lt;u32&gt; = None.unwrap();
</code></pre></pre>
</summary>A:    <span style='color:red'>The program panics!</span> You cannot unwrap() a None, use `unwrap_or(...)` instead</details>
<hr />
<details><summary>Q:  What is the difference between <code>unwrap_or</code> and `unwrap_or_else`?
</summary>A:  `unwrap_or_else` is lazy, `unwrap_or` is eager.
So unwrap_or_else is generally for passing a closure which is evaluated only when needed and unwrap_or is for an existing literal value known at the time of execution. `unwrap_or_else` expects a `Fn<()>` so you cannot just provide a literal or a simple expression.
`unwrap_or` on the otherhand will not accept a closure.
<pre><pre class="playground"><code class="language-rust editable">fn foo(k: u32) -&gt; u32 {
    println!(&quot;eager ran&quot;);
    2 * k
}
assert_eq!(Some(&quot;car&quot;).unwrap_or(&quot;bike&quot;), &quot;car&quot;);
assert_eq!(None.unwrap_or(&quot;bike&quot;), &quot;bike&quot;);
assert_eq!(None.unwrap_or_else(||{ &quot;bike&quot; }), &quot;bike&quot;);
let k = 10;
assert_eq!(Some(4).unwrap_or(foo(k)), 4);
assert_eq!(Some(4).unwrap_or_else(|| {println!(&quot;lazy did not run&quot;); 2 * k}), 4);
assert_eq!(None.unwrap_or_else(|| {println!(&quot;lazy ran&quot;); 2 * k}), 20);
println!(&quot;it ran&quot;);
</code></pre></pre>
</details>
<details><summary>Q:  What is the another way to think of `&mut x`?</summary>A:  Ryan Levick says `&mut x` is more correctly viewed as **exclusive** reference, **not** a mutable reference.</details><div style="break-before: page; page-break-before: always;"></div><h1 id="references-1"><a class="header" href="#references-1">References</a></h1>
<ul>
<li><a href="https://doc.rust-lang.org/book/title-page.html">Rust Book</a></li>
<li><a href="https://rust-lang-nursery.github.io/rust-cookbook/">Rust Cookbook</a></li>
<li><a href="https://play.rust-lang.org">Rust Playground</a></li>
<li><a href="https://www.tutorialspoint.com/rust/index.htm">Rust Tutorial</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example">Rust By Example</a></li>
<li><a href="https://nikolaivazquez.com/rust-workshop/#1">Rust Powerpoint</a></li>
</ul>
<h2 id="blogs"><a class="header" href="#blogs">Blogs</a></h2>
<ul>
<li><a href="https://exphp.github.io/">The Diagonal Device</a>
mattgraham has some seriously helpful post on metaprogramming
<ul>
<li><a href="https://exphp.github.io/2019/05/05/enums-of-vectors-part-1.html">Enums of Vectors</a></li>
<li><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=dd5cf4f3119903f83c46a9587ada1ca9">Debuggable</a> print out text of closure or function name.
https://exphp.github.io/
https://stevedonovan.github.io/rustifications/</li>
</ul>
</li>
</ul>
<h2 id="youtube-tutorials"><a class="header" href="#youtube-tutorials">YouTube Tutorials</a></h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=4DqP57BHaXI">Chat Server</a></li>
</ul>
<h2 id="excercises"><a class="header" href="#excercises">Excercises</a></h2>
<ul>
<li><a href="https://projecteuler.net/">Project Euler</a>
<ul>
<li>No solutions, just do these exercises as practice.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="notes-on-vscode"><a class="header" href="#notes-on-vscode">Notes on VSCode</a></h1>
<h2 id="extensions"><a class="header" href="#extensions">Extensions</a></h2>
<h3 id="bookmarks"><a class="header" href="#bookmarks">Bookmarks</a></h3>
<p>Jumping back and forth in several files can be a challenge.
F12 to jump to definition, then you want to jump back:
if it is a different file you could close.</p>
<p>If you want to jump around with bookmarks</p>
<p>Quickly navigate using bookmarks</p>
<ul>
<li>Ctrl + Alt + J  prev</li>
<li>Ctrl + Alt + K  toggle on/off</li>
<li>Ctrl + Alt + L  next</li>
<li>Ctrl + Alt + ;  clear all in current file (my mapping)</li>
<li>Ctrl + Alt + ,  list bookmarks</li>
</ul>
<h3 id="bookmarks-1"><a class="header" href="#bookmarks-1">Bookmarks</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tools"><a class="header" href="#tools">tools</a></h1>
<h2 id="repl"><a class="header" href="#repl">REPL</a></h2>
<p>Decent REPL for writing pieces of code
<code>https://lib.rs/crates/evcxr_repl</code> </p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
