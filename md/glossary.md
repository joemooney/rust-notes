# Glossary

### [Rustonomicom](https://doc.rust-lang.org/nomicon/index.html)

A book about writing unsafe code and the inner guts of Rust. |

### block

A block is a set of statements enclosed in braces {...}.
A block is an *expression*.
Before the statements where may be *inner attributes*.

### bound

When type is `bounded by` a capability it must provide that capability if required by any code that has access to variable of that type.

### bound `T: 'static`

Note: `T: 'static` includes owned types.
A variable with this capability *could* be accessible for the lifetime of the program **if that part of the code requires it to be so**. That part of the code may not require it to be accessible for the lifetime of the program and if it owns the variable then it may drop it and the variable would obviously not have had a lifetime for the full duration of the program.

### attributes

    - Built-in attributes
    - Macro attributes
    - Derive macro helper attributes
    - Tool attributes

### inner attributes

Inner attributes ```#![allow(unused_variables)]``` apply to the item containing the attribute. Within a block this means the block may contain unused variables.

### outer attributes

Outer attributes ```#[test]``` apply to the *thing* that follows the attribute.

### Statement

A statement is a component of a block, which is in turn a component of an *outer expression* or *function*. Rust has two kinds of statement: declaration statements and expression statements.

### expression statement

An *expression statement* is one that evaluates an *expression* and ignores its result.

### expression

An expression may have two roles: it always produces a value, and it may have effects (otherwise known as "side effects"). An expression evaluates to a value, and has effects during evaluation. Many expressions contain sub-expressions (operands).

### Declaration statements

A declaration statement is one that introduces one or more names into the enclosing statement block. The declared names may denote new variables or new items.
The two kinds of declaration statements are item declarations and let statements.

### monomorphic/polymorphic

A *generic* function is *monomorphic*. A function taking a *trait object* as an argument is *polymorphic*.
There is a separate function generated by the compiler for each different type used to call a *monomorphic* function.
There is just one *polymorphic* function generated by the compiler for a *polymorphic* function and *static dispatch* is employed at runtime to call *concrete* methods of the abstract *trait object*.

The *monomorphic* function is like a C++ templated function.
The *polymorphic* function is like a C++ base class virtual method or Java interface.
*monomorphic* is more efficient and can be inlined.

### function pointer

Function pointer types, written using the fn keyword, refer to a function whose identity is not necessarily known at compile-time.

```rust
fn add_one(x: i32) -> i32 {
    x + 1
}
fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {
    f(arg) + f(arg)
}
fn main() {
    let answer = do_twice(add_one, 5);
    println!("The answer is: {}", answer);
}
```

Unlike *closures*, fn is a *type* rather than a *trait*, so we specify fn as the *parameter type* directly rather than declaring a *generic type parameter* with one of the Fn traits as a *trait bound*.

### shadow/shadowed variable

A different variable declared with the same name, the first is no longer accessible. The first is not dropped until out of scope. The second declaration does not trigger a drop.

### drop/drop scope

A variable is dropped when it goes out of scope. This is called the variables *drop scope*. *Drop* is the trait which can be implemented to control behavior when dropped.

### bind/bound

A variable is *bound* to a value. |
A module is *bound to the current scope* via the ```use``` statement. ```use p::q::{r, s}``` both *r* and *s* are bound in the current but not *q*. Use ```use p::q::{self, r, s}``` to also bind *q* in the current but not *q*.

### Enumeration

An *enumeration* or *enum* is a type that can be one of multiple *variants*.

### variant

A *variant* is one of the types an *enumeration* can take.

### crate

Per the book: A crate is tree of modules that produces a library or executable.
A crate is a collection of Rust source files. It is what ```cargo build``` builds. It can either be a *library crate*  which typically has a lib.rs or a *binary crate* which has a main.rs. If a package has both a main.rs and a lib.rs then you have two crates. A crate is configured using a *Cargo.toml* file.

### library crate

A *library crate*

### binary crate

A *binary crate* is an executable.

### match expression

A ```match``` statement is an expression. It has a value to match against and a number of *arms* each with a pattern and code to execute if the pattern matches.

### expression

An *expression* is a statement that returns a value.

### currying

Instead of a function with multiple arguments, you break it down into several functions that each take a single argument and return a function taking a single argument. For the last argument you have a function which takes the final argument and returns the desired value. Each step of the currying process is basically taking a function and substituting the variable with the corresponding argument resulting in a new function. This is cool since you can generate functions at run time and store as objects and pass as arguments etc. Currying allows for easier formal proofs of program correctness.

### method

A *method* is a function defined in the *impl* block for a type.
A method is called via ```my_object.method_name(args, ...)```

### Semantic Versioning

Semantic versioning or *semver* is of the form **x.y.z** where *x* is the major version for incompatible API updates, *y* is for backwards compatible functionality updates, and *z* version when you make backwards compatible bug fixes.

### iterator adapters

Functions which take an Iterator and return another Iterator are often called 'iterator adapters', as they're a form of the 'adapter pattern'.

### iterator

Iterator is a trait with method `next` which returns `Some(Item)` as it iterates thru Items and returns `None` when there are no more items.

### method

Methods are functions attached to objects which have access to the data of the object and its other methods via the ```self``` keyword and defined in an ```impl``` block.

A method may either be a ```static``` or and ```instance``` method.

### static method

A static method does not have ```self``` as the first parameter.

### instance method

An instance method has ```self``` as the first parameter.

### external trait/external type

A trait or type that is not defined in the current module. You cannot implement an external trait on an external type but you can implement an external trait on a type you defined and someone
else can implement a trait defined in your module in one of their modules on their own type.

## cargo

Rust's package manager and build system. `cargo --version` `cargo build` `cargo run` `cargo install` `cargo check` `cargo new {name}`

## package

Per the book: A package is one or more crates that provide a set of functionality. There can be at most one library and any number of binary crates in the package. Each file in src/bin is a separate binary crate.

## rustup

The command to upgrade your Rust compiler: `rustup update`

## rustc

The rust compiler, `rustc --version`

## Fully Qualified Method Calls

```<str as ToString>::to_string("hi)``` is the fully qualified method call for qualified method call ```ToString::to_string("hi")``` or ```str::to_string("hi")```, all of which equate to the simplest form ```"hi".to_string()```

## object safe

A trait is object safe if the concrete is reffered by ```&self``` reference tnd not by ```self``` value.

```
trait T1 {
    fn foo(self); // not object safe,
                  // size of object is unknowable at compile time.
}

trait T2 {
    fn foo(&self); // object safe
}
```

## Dynamic Dispatch

The concrete type of an object is unknown at compile time.

```
fn foo(o: dyn MyTrait) {  // this will not compile, unknown size
}
```

## Monomorphism

```
fn foo(o: impl MyTrait) {  // this will compile
}
```

## use

The use keyword as in ```use x::y::z``` brings public items into scope. If z contains items (e.g. x::y::z::foo) then they can be refereced like ```z::foo```, if z is an item (say an enum or struct) then it can be accessed using just `z` and not using ```x::y::z```. You don't need to have a `use` statement. You can access any item that your package knows about using a full path in the code (e.g x::y::z::foo())

## pub use

The `pub` in front of the `use` **reexports** the items from whatever you are using to appear as they are defined within this module. For example, ```pub use x::y::Foo``` in module m, means that code that has a ```use m``` can use m::Foo instead of using x::y::Foo.

## module

A **module** is a namespace in which your items can be either `public` or `private`. A module named `xyz` is defined in one of three ways:

* a ```mod xyz {...}``` block
* a file `xyx.rs` that is imported into your crate via a `mod xzy;` statement
* a subdirectory named `xyz` that contains a `mod.rs` file, likewise imported into your crate via a `mod xyz;` statement.
Child modules can use `private` parent modules items but not vice-versa.
